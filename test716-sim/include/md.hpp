// Molecular dynamics microframework
// Version: unreleased
// Source:  https://github.com/snsinfu/micromd

// Copyright snsinfu 2018.
// Distributed under the Boost Software License, Version 1.0.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef MICROMD_MD_HPP
#define MICROMD_MD_HPP


//------------------------------------------------------------------------------
// md/basic_types/array_view.hpp
//------------------------------------------------------------------------------

// This module provides array_view, a lightweight class template for adapting
// raw arrays as ranges.
// Source: https://github.com/snsinfu/cxx-array_view

#include <cstddef>
#include <iterator>
#include <stdexcept>
#include <type_traits>
#include <utility>


namespace md
{
    namespace array_view_detail
    {
        // data returns a pointer to the first element of a contiguous container
        // or an array.
        template<typename Cont>
        constexpr auto data(Cont& cont) noexcept -> decltype(cont.data())
        {
            return cont.data();
        }

        template<typename T, std::size_t N>
        constexpr auto data(T(& arr)[N]) noexcept -> T*
        {
            return arr;
        }

        // size returns the number of elements in a container or an array.
        template<typename Cont>
        constexpr auto size(Cont const& cont) noexcept -> decltype(cont.size())
        {
            return cont.size();
        }

        template<typename T, std::size_t N>
        constexpr auto size(T(&)[N]) noexcept -> std::size_t
        {
            return N;
        }
    }

    // array_view is an non-owning range view of an array. It is similar to
    // GSL's span but uses size_t for indexing, for better compatibility with
    // the standard library.
    template<typename T>
    class array_view
    {
    public:
        // value_type is the non-qualified type of the elements.
        using value_type = typename std::remove_cv<T>::type;

        // pointer is the type of a pointer to an element.
        using pointer = T*;

        // reference is the type of a reference to an element.
        using reference = T&;

        // size_type is the type of size and index values.
        using size_type = std::size_t;

        // iterator is the type of iterators. Guaranteed to be a random access
        // iterator. Currently this is implemented as an alias of T* but this
        // may change in the future.
        using iterator = T*;

        // reverse_iterator is the type of reverse iterators. Guaranteed to be
        // a random access iterator.
        using reverse_iterator = std::reverse_iterator<iterator>;

        // const_array_view is the type of read-only array_view with the same
        // value_type. This is the same as array_view<T> if T is already const
        // qualified.
        using const_array_view = array_view<T const>;

        // array_view is default constructible.
        array_view() = default;

        // array_view is copy constructible.
        array_view(array_view&) = default;

        // array_view is copy constructible.
        array_view(array_view const&) = default;

        // array_view is constructible from a raw memory span [p, p + n). The
        // behavior is undefined if the memory region is invalid.
        constexpr array_view(pointer p, size_type n)
            : data_{p}, size_{n}
        {
        }

        // array_view is implicitly convertible from a contiguous container like
        // std::vector.
        template<
            typename Container,
            typename P = decltype(array_view_detail::data(std::declval<Container&>())),
            typename S = decltype(array_view_detail::size(std::declval<Container&>())),
            typename = typename std::enable_if<
                std::is_convertible<typename std::remove_pointer<P>::type(*)[], T(*)[]>::value,
                int
            >::type,
            typename = typename std::enable_if<
                !std::is_same<Container, array_view<value_type>>::value,
                int
            >::type
        >
        constexpr array_view(Container& container) noexcept
            : array_view{array_view_detail::data(container), array_view_detail::size(container)}
        {
        }

        // array_view is implicitly convertible to a read-only view.
        constexpr operator const_array_view() const noexcept
        {
            return {data(), size()};
        }

        // empty returns true if the view is empty.
        constexpr bool empty() const noexcept
        {
            return size() == 0;
        }

        // size returns the number of elements.
        constexpr size_type size() const noexcept
        {
            return size_;
        }

        // data r eturns a pointer to the first element. The pointer may or may
        // not be null if the view is empty.
        constexpr pointer data() const noexcept
        {
            return data_;
        }

        // front returns a reference to the first element. The behavior is
        // undefined if the view is empty.
        constexpr reference front() const
        {
            return operator[](0);
        }

        // back returns a reference to the last element. The behavior is
        // undefined if the view is empty.
        constexpr reference back() const
        {
            return operator[](size() - 1);
        }

        // Indexing operator returns a reference to the idx-th element. The
        // behavior is undefined if the index is out of bounds.
        constexpr reference operator[](size_type idx) const
        {
            return data()[idx];
        }

        // at returns a reference to the idx-th element. It throws
        // std::out_of_range if the index is out of bounds.
        reference at(size_type idx) const
        {
            if (idx >= size()) {
                throw std::out_of_range("array_view access out-of-bounds");
            }
            return operator[](idx);
        }

        // begin returns an iterator to the beginning of the viewed array.
        constexpr iterator begin() const noexcept
        {
            return data();
        }

        // end returns an iterator to the end of the viewed array.
        constexpr iterator end() const noexcept
        {
            return data() + size();
        }

        // rbegin returns a reverse iterator to the reverse beginning.
        reverse_iterator rbegin() const noexcept
        {
            return reverse_iterator{end()};
        }

        // rend returns a reverse iterator to the reverse end.
        reverse_iterator rend() const noexcept
        {
            return reverse_iterator{begin()};
        }

        // as_const returns a read-only view of the same array.
        constexpr const_array_view as_const() const noexcept
        {
            return {data(), size()};
        }

        // swap swaps the viewed array with other.
        void swap(array_view& other) noexcept
        {
            auto const copy = *this;
            *this = other;
            other = copy;
        }

        // subview returns a view of the subarray with given region.
        constexpr array_view subview(size_type offset, size_type count) const
        {
            return {data() + offset, count};
        }

        // first returns a view of the first count elements.
        constexpr array_view first(size_type count) const
        {
            return subview(0, count);
        }

        /// last returns a view of the last count elements.
        constexpr array_view last(size_type count) const
        {
            return subview(size() - count, count);
        }

    private:
        pointer data_ = nullptr;
        size_type size_ = 0;
    };
}

//------------------------------------------------------------------------------
// md/basic_types/point.hpp
//------------------------------------------------------------------------------

// This module provides basic three-dimensional geometry classes and functions.
// Source: https://github.com/snsinfu/cxx-point

#include <cmath>
#include <cstddef>
#include <istream>
#include <ostream>


namespace md
{
    namespace point_detail
    {
        // coordinates hold three-dimensional cartesian coordinate values.
        struct coordinates
        {
            double x = 0;
            double y = 0;
            double z = 0;

            // Default constructor initializes coordinates to zero.
            coordinates() = default;

            // Constructor initializes coordinates to specified values.
            inline coordinates(double x_init, double y_init, double z_init)
                : x{x_init}, y{y_init}, z{z_init}
            {
            }

            // Index 0, 1 and 2 correspond to x, y and z, respectively.
            inline double& operator[](std::size_t idx)
            {
                double* coords[] = {
                    &x,
                    &y,
                    &z
                };
                return *coords[idx];
            }

            // Index 0, 1 and 2 correspond to x, y and z, respectively.
            inline double const& operator[](std::size_t idx) const
            {
                double const* coords[] = {
                    &x,
                    &y,
                    &z
                };
                return *coords[idx];
            }
        };

        // ostream operator formats coords as space-delimited floating-point
        // coordinate values.
        template<typename Char, typename Tr>
        std::basic_ostream<Char, Tr>& operator<<(
            std::basic_ostream<Char, Tr>& os,
            coordinates const& coords
        )
        {
            using sentry_type = typename std::basic_ostream<Char, Tr>::sentry;

            if (sentry_type sentry{os}) {
                Char const delim = os.widen(' ');
                os << coords.x << delim << coords.y << delim << coords.z;
            }

            return os;
        }

        // istream operator parses space-delimited floating-point coordinate
        // values into coords.
        template<typename Char, typename Tr>
        std::basic_istream<Char, Tr>& operator>>(
            std::basic_istream<Char, Tr>& is,
            coordinates& coords
        )
        {
            using sentry_type = typename std::basic_istream<Char, Tr>::sentry;

            if (sentry_type sentry{is}) {
                is >> coords.x >> coords.y >> coords.z;
            }

            return is;
        }
    }

    // vector is a three-dimensional vector with cartesian coordinates.
    struct vector : point_detail::coordinates
    {
        using point_detail::coordinates::coordinates;

        // Component-wise addition.
        inline vector& operator+=(vector const& other) noexcept
        {
            x += other.x;
            y += other.y;
            z += other.z;
            return *this;
        }

        // Component-wise subtraction.
        inline vector& operator-=(vector const& other) noexcept
        {
            x -= other.x;
            y -= other.y;
            z -= other.z;
            return *this;
        }

        // Scalar multiplication is broadcast to all components.
        inline vector& operator*=(double mult) noexcept
        {
            x *= mult;
            y *= mult;
            z *= mult;
            return *this;
        }

        // Scalar division is broadcast to all components.
        inline vector& operator/=(double divisor)
        {
            return *this *= 1 / divisor;
        }

        // dot returns the dot product of this vector and other.
        inline double dot(vector const& other) const noexcept
        {
            return (
                x * other.x +
                y * other.y +
                z * other.z
            );
        }

        // cross returns the cross product of this vector and rhs.
        inline vector cross(vector const& rhs) const noexcept
        {
            return vector {
                y * rhs.z - z * rhs.y,
                z * rhs.x - x * rhs.z,
                x * rhs.y - y * rhs.x
            };
        }

        // hadamard returns the hadamard product of this vector and rhs.
        inline vector hadamard(vector const& rhs) const noexcept
        {
            return vector {
                x * rhs.x,
                y * rhs.y,
                z * rhs.z
            };
        }

        // norm returns the Euclidean norm of this vector.
        inline double norm() const noexcept
        {
            return std::sqrt(squared_norm());
        }

        // squared_norm returns the squared Euclidean norm of this vector.
        inline double squared_norm() const noexcept
        {
            return dot(*this);
        }

        // normalize returns the unit vector that is parallel to this vector.
        // Behavior is undefined if this vector is zero.
        inline vector normalize() const
        {
            return vector{*this} /= norm();
        }

        // project returns this vector projected onto the line defined by axis.
        // Behavior is undefined if axis is zero.
        inline vector project(vector const& axis) const
        {
            return vector{axis} *= dot(axis) / axis.squared_norm();
        }
    };

    // Unary no-op `+vec` returns a copy of vec.
    inline vector operator+(vector const& vec) noexcept
    {
        return vec;
    }

    // Unary negation `-vec` returns an anti-parallel copy of vec.
    inline vector operator-(vector const& vec) noexcept
    {
        return {-vec.x, -vec.y, -vec.z};
    }

    // Sum `lhs + rhs` returns a vector with component-wise sum of lhs and rhs.
    inline vector operator+(vector const& lhs, vector const& rhs) noexcept
    {
        return vector{lhs} += rhs;
    }

    // Difference `lhs - rhs` returns a vector with component-wise difference of
    // lhs and rhs.
    inline vector operator-(vector const& lhs, vector const& rhs) noexcept
    {
        return vector{lhs} -= rhs;
    }

    // Multiplication `vec * mult` returns vec with each component scaled by
    // mult.
    inline vector operator*(vector const& vec, double mult) noexcept
    {
        return vector{vec} *= mult;
    }

    // Multiplication `mult * vec` returns vec with each component scaled by
    // mult.
    inline vector operator*(double mult, vector const& vec) noexcept
    {
        return vector{vec} *= mult;
    }

    // Division `vec / divisor` returns vec with each component scaled by
    // 1/divisor.
    inline vector operator/(vector const& vec, double divisor)
    {
        return vector{vec} /= divisor;
    }

    // dot returns the dot product of lhs and rhs.
    inline double dot(vector const& lhs, vector const& rhs) noexcept
    {
        return lhs.dot(rhs);
    }

    // cross returns the cross product of lhs and rhs.
    inline vector cross(vector const& lhs, vector const& rhs) noexcept
    {
        return lhs.cross(rhs);
    }

    // hadamard returns the hadamard product of lhs and rhs.
    inline vector hadamard(vector const& lhs, vector const& rhs) noexcept
    {
        return lhs.hadamard(rhs);
    }

    // norm returns the Euclidean norm of vec.
    inline double norm(vector const& vec) noexcept
    {
        return vec.norm();
    }

    // squared_norm returns the squares Euclidean norm of vec.
    inline double squared_norm(vector const& vec) noexcept
    {
        return vec.squared_norm();
    }

    // normalize returns the unit vector that is parallel to vec.
    inline vector normalize(vector const& vec) noexcept
    {
        return vec.normalize();
    }

    // project returns vec projected onto the line defined by axis.
    inline vector project(vector const& vec, vector const& axis) noexcept
    {
        return vec.project(axis);
    }

    // point is a cartesian representation of a point in the three-dimensional
    // Euclidean space.
    struct point : point_detail::coordinates
    {
        using point_detail::coordinates::coordinates;
        using vector_t = struct vector;

        // vector returns the coordinate vector of this point.
        inline vector_t vector() const noexcept
        {
            return vector_t{x, y, z};
        }

        // Adding a vector translates the point.
        inline point& operator+=(vector_t const& disp) noexcept
        {
            x += disp.x;
            y += disp.y;
            z += disp.z;
            return *this;
        }

        // Subtracting a vector translates the point.
        inline point& operator-=(vector_t const& disp) noexcept
        {
            x -= disp.x;
            y -= disp.y;
            z -= disp.z;
            return *this;
        }

        // distance returns the Euclidean distance between this point and other.
        inline double distance(point const& other) const noexcept
        {
            return (vector() - other.vector()).norm();
        }

        // squared_distance returns the squared Euclidean distance between this
        // point and other.
        inline double squared_distance(point const& other) const noexcept
        {
            return (vector() - other.vector()).squared_norm();
        }
    };

    // Sum `pt + disp` returns the point pt translated by disp.
    inline point operator+(point const& pt, vector const& disp) noexcept
    {
        return point{pt} += disp;
    }

    // Difference `pt - disp` returns the point pt translated by -disp.
    inline point operator-(point const& pt, vector const& disp) noexcept
    {
        return point{pt} -= disp;
    }

    // Difference `pa - pb` returns the displacement vector from pb towards pa.
    inline vector operator-(point const& pa, point const& pb) noexcept
    {
        return pa.vector() - pb.vector();
    }

    // distance returns the Euclidean distance between pa and pb.
    inline double distance(point const& pa, point const& pb) noexcept
    {
        return pa.distance(pb);
    }

    // squared_distance returns the squared Euclidean distance between pa and
    // pb.
    inline double squared_distance(point const& pa, point const& pb) noexcept
    {
        return pa.squared_distance(pb);
    }
}

//------------------------------------------------------------------------------
// md/basic_types/sfc.hpp
//------------------------------------------------------------------------------

// This module provides a small fast random engine.
// Source: https://github.com/snsinfu/cxx-sfcrandom

#include <cstdint>
#include <istream>
#include <limits>
#include <ostream>


namespace md
{
    namespace sfc_detail
    {
        // rotate returns the left rotation of x.
        template<typename T>
        inline T rotate(T x, int n)
        {
            // Avoid UB.
            if (n == 0) {
                return x;
            } else {
                return T(x << n) | T(x >> (std::numeric_limits<T>::digits - n));
            }
        }

        // state holds sfc generator state variables.
        template<typename T>
        struct state
        {
            T a = 0;
            T b = 0;
            T c = 0;
            T counter = 1;

            // init initializes state variables using given 64-bit seed.
            void init(std::uint64_t seed_val) noexcept;

            // init_seq initializes state variables using words read from given
            // sequence. Lower bits are taken first.
            template<typename SeedSeq>
            void init_seq(SeedSeq& seed_seq);
        };

        template<>
        inline void state<std::uint16_t>::init(std::uint64_t seed_val) noexcept
        {
            a = std::uint16_t(seed_val);
            b = std::uint16_t(seed_val >> 16);
            c = std::uint16_t(seed_val >> 32);
            counter = std::uint16_t(seed_val >> 48);
        }

        template<>
        inline void state<std::uint32_t>::init(std::uint64_t seed_val) noexcept
        {
            a = 0;
            b = std::uint32_t(seed_val);
            c = std::uint32_t(seed_val >> 32);
            counter = 1;
        }

        template<>
        inline void state<std::uint64_t>::init(std::uint64_t seed_val) noexcept
        {
            a = seed_val;
            b = seed_val;
            c = seed_val;
            counter = 1;
        }

        template<>
        template<typename SeedSeq>
        inline void state<std::uint16_t>::init_seq(SeedSeq& seed_seq)
        {
            std::uint32_t uints[2];
            seed_seq.generate(uints, uints + 2);

            a = std::uint16_t(uints[0]);
            b = std::uint16_t(uints[0] >> 16);
            c = std::uint16_t(uints[1]);
            counter = 1;
        }

        template<>
        template<typename SeedSeq>
        inline void state<std::uint32_t>::init_seq(SeedSeq& seed_seq)
        {
            std::uint32_t uints[3];
            seed_seq.generate(uints, uints + 3);

            a = uints[0];
            b = uints[1];
            c = uints[2];
            counter = 1;
        }

        template<>
        template<typename SeedSeq>
        inline void state<std::uint64_t>::init_seq(SeedSeq& seed_seq)
        {
            std::uint32_t uints[6];
            seed_seq.generate(uints, uints + 6);

            a = std::uint64_t(uints[0]) << 32 | uints[1];
            b = std::uint64_t(uints[2]) << 32 | uints[3];
            c = std::uint64_t(uints[4]) << 32 | uints[5];
            counter = 1;
        }

        // Equality comparison operator compares the member-wise equality.
        template<typename T>
        bool operator==(state<T> const& s1, state<T> const& s2) noexcept
        {
            return s1.a == s2.a
                && s1.b == s2.b
                && s1.c == s2.c
                && s1.counter == s2.counter;
        }

        template<typename T>
        bool operator!=(state<T> const& s1, state<T> const& s2) noexcept
        {
            return !(s1 == s2);
        }

        // stream_restorer saves and restores stream flags.
        template<typename Char, typename Tr>
        class stream_restorer
        {
        public:
            using char_type = Char;
            using stream_type = std::basic_ios<Char, Tr>;
            using flags_type = typename stream_type::fmtflags;

            stream_restorer(stream_restorer const&) = delete;
            stream_restorer& operator=(stream_restorer const&) = delete;

            // Constructor saves the stream flags.
            explicit stream_restorer(stream_type& stream)
                : stream_(stream), flags_(stream.flags()), fill_(stream.fill())
            {
            }

            // Destructor restores the saved stream flags.
            ~stream_restorer()
            {
                stream_.flags(flags_);
                stream_.fill(fill_);
            }

        private:
            stream_type& stream_;
            flags_type flags_;
            char_type fill_;
        };

        // Stream output operator writes state variables to a stream in decimal
        // format with white-space delimiter.
        template<typename Char, typename Tr, typename T>
        std::basic_ostream<Char, Tr>& operator<<(
            std::basic_ostream<Char, Tr>& os,
            state<T> const& st
        )
        {
            using sentry_type = typename std::basic_ostream<Char, Tr>::sentry;

            if (sentry_type sentry{os}) {
                Char const space = os.widen(' ');

                stream_restorer<Char, Tr> restorer{os};
                os.flags(std::ios::dec | std::ios::left);
                os.fill(space);

                os << st.a << space
                   << st.b << space
                   << st.c << space
                   << st.counter;
            }

            return os;
        }

        // Stream input operator reads state variables from a stream.
        template<typename Char, typename Tr, typename T>
        std::basic_istream<Char, Tr>& operator>>(
            std::basic_istream<Char, Tr>& is,
            state<T>& st
        )
        {
            using sentry_type = typename std::basic_istream<Char, Tr>::sentry;

            if (sentry_type sentry{is}) {
                state<T> state;

                stream_restorer<Char, Tr> restorer{is};
                is.flags(std::ios::dec | std::ios::skipws);

                is >> state.a
                   >> state.b
                   >> state.c
                   >> state.counter;

                st = state;
            }

            return is;
        }

        // check_seed_seq is instanciatable if T satisfies the SeedSequence
        // concept.
        template<typename T>
        auto check_seed_seq(
            std::uint32_t* rb = nullptr,
            std::uint32_t* re = nullptr
        ) -> decltype(std::declval<T>().generate(rb, re));
    }

    // small_fast_counting_engine_v4 implements the sfc16, sfc32 and sfc64
    // random number generators found in PractRand. It implements the C++11
    // RandomNumberEngine concept.
    template<
        typename T,
        int Rot,
        int RSh,
        int LSh,
        unsigned long long Rnd1,
        unsigned long long Rnd3
    >
    class small_fast_counting_engine_v4
    {
        using state_type = sfc_detail::state<T>;

        static constexpr int rotation = Rot;
        static constexpr int right_shift = RSh;
        static constexpr int left_shift = LSh;

        // Initial round count for seed/1.
        static constexpr unsigned long long initial_round_1 = Rnd1;

        // Initial round count for seed/3.
        static constexpr unsigned long long initial_round_3 = Rnd3;

    public:
        // result_type is an alias of T.
        using result_type = T;

        // default_seed is the default seed value used by default constructor
        // and seed function.
        static constexpr result_type default_seed = 0;

        // min returns 0.
        static constexpr result_type min() noexcept
        {
            return 0;
        }

        // max returns a result_type with all bits set.
        static constexpr result_type max() noexcept
        {
            return result_type(-1);
        }

        // Constructor creates a seeded engine. This overload extends seed_val
        // to 64-bit and seeds the engine with the PractRand seed algorithm.
        explicit small_fast_counting_engine_v4(result_type seed_val = default_seed) noexcept
        {
            seed(seed_val);
        }

        // Constructor creates a seeded engine. This overload reads three words
        // from given sequence and seeds the engine with the PractRand seed/3
        // algorithm.
        template<
            typename SeedSeq,
            typename = decltype(sfc_detail::check_seed_seq<SeedSeq>())
        >
        explicit small_fast_counting_engine_v4(SeedSeq& seed_seq)
        {
            seed(seed_seq);
        }

        // seed re-seeds the engine. This overload extends seed_val to 64-bit
        // and seeds the engine with the PractRand seed/1 algorithm.
        void seed(result_type seed_val = default_seed) noexcept
        {
            seed64(std::uint64_t{seed_val});
        }

        // seed re-seeds the engine. This overload reads three words from given
        // sequence and seeds the engine with the PractRand seed/3 algorithm.
        template<
            typename SeedSeq,
            typename = decltype(sfc_detail::check_seed_seq<SeedSeq>())
        >
        void seed(SeedSeq& seed_seq)
        {
            state_.init_seq(seed_seq);
            discard(initial_round_3);
        }

        // seed64 seeds the engine using given 64-bit value using the PractRand
        // seed/1 algorithm. This function is a non-standard extension.
        void seed64(std::uint64_t seed_val) noexcept
        {
            state_.init(seed_val);
            discard(initial_round_1);
        }

        // Invocation operator advances the engine state and returns the
        // generated value.
        inline result_type operator()() noexcept
        {
            auto& a = state_.a;
            auto& b = state_.b;
            auto& c = state_.c;
            auto& counter = state_.counter;

            auto const output = result_type(a + b + counter++);
            a = result_type(b ^ result_type(b >> right_shift));
            b = result_type(c + result_type(c << left_shift));
            c = result_type(sfc_detail::rotate(c, rotation) + output);

            return output;
        }

        // discard advances the engine state by z. The time complexity is O(z).
        void discard(unsigned long long z) noexcept
        {
            for (; z != 0; z--) {
                (*this)();
            }
        }

        // Equality comparison operator compares two engines for their states.
        friend bool operator==(
            small_fast_counting_engine_v4 const& e1,
            small_fast_counting_engine_v4 const& e2
        ) noexcept
        {
            return e1.state_ == e2.state_;
        }

        friend bool operator!=(
            small_fast_counting_engine_v4 const& e1,
            small_fast_counting_engine_v4 const& e2
        ) noexcept
        {
            return !(e1 == e2);
        }

        // Stream output operator writes the engine state to stream.
        template<typename Char, typename Tr>
        friend std::basic_ostream<Char, Tr>& operator<<(
            std::basic_ostream<Char, Tr>& os,
            small_fast_counting_engine_v4 const& engine
        )
        {
            return os << engine.state_;
        }

        // Stream input operator loads engine state from stream.
        template<typename Char, typename Tr>
        friend std::basic_istream<Char, Tr>& operator>>(
            std::basic_istream<Char, Tr>& is,
            small_fast_counting_engine_v4& engine
        )
        {
            return is >> engine.state_;
        }

    private:
        state_type state_;
    };

    // sfc16 is the standard 16-bit variant of small_fast_counting_engine_v4.
    // The parameters are taken from PractRand 0.94.
    using sfc16 = small_fast_counting_engine_v4<std::uint16_t, 6, 5, 3, 10, 10>;

    // sfc32 is the standard 32-bit variant of small_fast_counting_engine_v4.
    // The parameters are taken from PractRand 0.94.
    using sfc32 = small_fast_counting_engine_v4<std::uint32_t, 21, 9, 3, 12, 15>;

    // sfc64 is the standard 64-bit variant of small_fast_counting_engine_v4.
    // The parameters are taken from PractRand 0.94.
    using sfc64 = small_fast_counting_engine_v4<std::uint64_t, 24, 11, 3, 12, 18>;
}

//------------------------------------------------------------------------------
// md/basic_types/ziggurat.hpp
//------------------------------------------------------------------------------

// This module provides a fast normal random number generation algorithm.
// Source: https://github.com/snsinfu/cxx-ziggurat

#include <cmath>
#include <cstddef>
#include <cstdint>
#include <ios>
#include <istream>
#include <limits>
#include <ostream>
#include <random>


#if defined(__GNUC__)
# define ZIGGURAT_LIKELY(x) __builtin_expect((x), 1)
# define ZIGGURAT_NOINLINE __attribute__((noinline))
#else
# define ZIGGURAT_LIKELY(x) (x)
# define ZIGGURAT_NOINLINE
#endif


namespace md
{
    namespace ziggurat_detail
    {
        // is_pow2m1 checks if num + 1 is a power of two.
        template<typename T>
        inline constexpr bool is_pow2m1(T num)
        {
            return (num & (num + 1)) == 0;
        }

        // log2 computes the base-2 logarithm of num truncated to integer.
        inline constexpr std::size_t log2(std::uint64_t num)
        {
            return num / 2 ? 1 + log2(num / 2) : 0;
        }

        // generate_bits draws N random bits from given random number generator.
        template<std::size_t N, typename URNG>
        inline std::uint64_t generate_bits(URNG& random)
        {
            constexpr std::uint64_t mask = (std::uint64_t(1) << N) - 1;

            if (URNG::min() == 0 && URNG::max() >= mask && is_pow2m1(URNG::max())) {
                return std::uint64_t(random()) & mask;
            } else {
                std::uniform_int_distribution<std::uint64_t> dist(0, mask);
                return dist(random);
            }
        }

        // canonicalize transforms N bits into a floating-point number in [0, 1).
        template<std::size_t N, typename T>
        inline T canonicalize(std::uint64_t bits)
        {
            constexpr int real_bits = std::numeric_limits<T>::digits;
            constexpr int uint_bits = N;
            constexpr int data_bits = (real_bits < uint_bits ? real_bits : uint_bits);
            constexpr T norm = 1 / T(std::int64_t(1) << data_bits);
            return norm * T(bits >> (uint_bits - data_bits));
        }

        // gaussian returns exp(-x^2/2).
        template<typename T>
        inline T gaussian(T x)
        {
            return std::exp(T(-0.5) * x * x);
        }

        // normal_ziggurat holds a pre-computed ziggurat table.
        template<typename T>
        struct normal_ziggurat
        {
            static T const edges[0x81];
        };
    }

    // ziggurat_normal_distribution generates normal random numbers using the fast
    // ziggurat algorithm.
    template<typename T>
    class ziggurat_normal_distribution
    {
        // Pull in the ziggurat table to use.
        using ziggurat = ziggurat_detail::normal_ziggurat<T>;

    public:
        // result_type is an alias of T.
        using result_type = T;

        // param_type holds distribution parameters.
        struct param_type
        {
            using distribution_type = ziggurat_normal_distribution;

            // Default constructor initializes mean to 0 and stddev to 1.
            param_type() = default;

            // Single-parameter constructor initializes mean and stddev to given
            // values.
            explicit param_type(result_type mean, result_type stddev = 1)
                : mean_{mean}, stddev_{stddev}
            {
            }

            // mean returns the mean parameter.
            inline result_type mean() const
            {
                return mean_;
            }

            // stddev returns the stddev parameter.
            inline result_type stddev() const
            {
                return stddev_;
            }

            // Equality comparison p1 == p2 returns true if and only if mean and
            // stddev parameters, respectively, are the same for p1 and p2.
            friend bool operator==(param_type const& p1, param_type const& p2)
            {
                return p1.mean_ == p2.mean_ && p1.stddev_ == p2.stddev_;
            }

            friend bool operator!=(param_type const& p1, param_type const& p2)
            {
                return !(p1 == p2);
            }

            // Stream output write mean and stddev to a stream.
            template<typename Char, typename Tr>
            friend std::basic_ostream<Char, Tr>& operator<<(
                std::basic_ostream<Char, Tr>& os,
                param_type const& param
            )
            {
                using sentry_type = typename std::basic_ostream<Char, Tr>::sentry;

                // TODO: need to normalize stream flags?

                if (sentry_type sentry{os}) {
                    Char const space = os.widen(' ');
                    os << param.mean_ << space << param.stddev_;
                }

                return os;
            }

            // Stream input reads mean and stddev from a stream.
            template<typename Char, typename Tr>
            friend std::basic_istream<Char, Tr>& operator>>(
                std::basic_istream<Char, Tr>& is,
                param_type& param
            )
            {
                using sentry_type = typename std::basic_istream<Char, Tr>::sentry;

                // TODO: need to normalize stream flags?

                if (sentry_type sentry{is}) {
                    param_type tmp;
                    if (is >> tmp.mean_ >> tmp.stddev_) {
                        param = tmp;
                    }
                }

                return is;
            }

        private:
            result_type mean_ = 0;
            result_type stddev_ = 1;
        };

        // Default constructor creates a normal distribution with mean = 0 and
        // stddev = 1.
        ziggurat_normal_distribution() = default;

        // This constructor creates a normal distribution with given mean and
        // stddev.
        explicit ziggurat_normal_distribution(result_type mean, result_type stddev = 1)
            : param_{mean, stddev}
        {
        }

        // This constructor creates a normal distribution having given
        // parameters.
        explicit ziggurat_normal_distribution(param_type const& param)
            : param_{param}
        {
        }

        // reset does nothing; this is a RandomNumberDistribution requirement.
        void reset()
        {
        }

        // Invoking a distribution with a random number engine returns a newly
        // generated normal random number with the preconfigured parameters.
        template<typename URNG>
        inline T operator()(URNG& random)
        {
            return param_.mean() + param_.stddev() * sample(random);
        }

        // Invoking a distribution with a random number engine and a parameter
        // object returns a newly generated normal random number with given
        // parameters.
        template<typename URNG>
        inline T operator()(URNG& random, param_type const& param)
        {
            return param.mean() + param.stddev() * sample(random);
        }

        // mean returns the mean parameter of this distribution.
        result_type mean() const
        {
            return param_.mean();
        }

        // stddev returns the stddev parameter of this distribution.
        result_type stddev() const
        {
            return param_.stddev();
        }

        // param returns the parameters of this distribution as a param_type.
        param_type param() const
        {
            return param_;
        }

        // param sets the parameters of this distribution.
        void param(param_type const& param)
        {
            param_ = param;
        }

        // min returns -infinity.
        result_type min() const
        {
            return -std::numeric_limits<result_type>::infinity();
        }

        // max returns +infinity.
        result_type max() const
        {
            return std::numeric_limits<result_type>::infinity();
        }

    private:
        // sample generates a standard normal number.
        template<typename URNG>
        inline T sample(URNG& random) const
        {
            constexpr std::size_t bit_count = ziggurat_detail::log2(URNG::max() - URNG::min());

            for (;;)
            {
                auto const bits = ziggurat_detail::generate_bits<bit_count>(random);
                auto const uniform = ziggurat_detail::canonicalize<bit_count, T>(bits);
                auto const layer = std::size_t(bits & 0x7F);
                auto const sign = T((bits & 0x80) ? 1 : -1);

                auto const lower_edge = ziggurat::edges[layer];
                auto const upper_edge = ziggurat::edges[layer + 1];

                auto const x = uniform * lower_edge;

                if (ZIGGURAT_LIKELY(x < upper_edge)) {
                    return sign * x;
                }

                if (layer == 0) {
                    return sign * sample_from_tail(random);
                }

                if (check_accept(random, lower_edge, upper_edge, x)) {
                    return sign * x;
                }
            }
        }

        template<typename URNG>
        ZIGGURAT_NOINLINE
        T sample_from_tail(URNG& random) const
        {
            T const tail_edge = ziggurat::edges[1];

            std::uniform_real_distribution<T> uniform;

            T x, y;
            do {
                x = -std::log(uniform(random)) / tail_edge;
                y = -std::log(uniform(random));
            } while (2 * y < x * x);

            return tail_edge + x;
        }

        template<typename URNG>
        ZIGGURAT_NOINLINE
        bool check_accept(URNG& random, T lower_edge, T upper_edge, T x) const
        {
            // Rejection sampling from the interval [upper_edge, lower_edge].
            std::uniform_real_distribution<T> uniform(
                ziggurat_detail::gaussian(lower_edge),
                ziggurat_detail::gaussian(upper_edge)
            );
            return uniform(random) < ziggurat_detail::gaussian(x);
        }

    private:
        param_type param_;
    };

    // Equality comparison d1 == d2 compares the equality of distribution
    // parameters.
    template<typename T>
    bool operator==(
        ziggurat_normal_distribution<T> const& d1,
        ziggurat_normal_distribution<T> const& d2
    )
    {
        return d1.param() == d2.param();
    }

    template<typename T>
    bool operator!=(
        ziggurat_normal_distribution<T> const& d1,
        ziggurat_normal_distribution<T> const& d2
    )
    {
        return !(d1 == d2);
    }

    // Stream output operator writes mean and stddev parameters to a stream.
    template<typename Char, typename Tr, typename T>
    std::basic_ostream<Char, Tr>& operator<<(
        std::basic_ostream<Char, Tr>& os,
        ziggurat_normal_distribution<T> const& dist
    )
    {
        return os << dist.param();
    }

    // Stream input operator reads mean and stddev parameters from a stream.
    template<typename Char, typename Tr, typename T>
    std::basic_istream<Char, Tr>& operator>>(
        std::basic_istream<Char, Tr>& is,
        ziggurat_normal_distribution<T>& dist
    )
    {
        typename ziggurat_normal_distribution<T>::param_type param;
        if (is >> param) {
            dist.param(param);
        }
        return is;
    }

    // Pre-computed ziggurat table.
    template<typename T>
    T const ziggurat_detail::normal_ziggurat<T>::edges[] = {
        T(3.71308624674036292), T(3.44261985589665231), T(3.22308498457861869), T(3.083228858214214),
        T(2.97869625264501714), T(2.89434400701867078), T(2.82312535054596658), T(2.76116937238415394),
        T(2.70611357311872291), T(2.65640641125819288), T(2.61097224842861353), T(2.56903362592163953),
        T(2.53000967238546703), T(2.49345452209195129), T(2.4590181774083506), T(2.42642064553021219),
        T(2.395434278007468), T(2.36587137011398818), T(2.3375752413355313), T(2.31041368369500244),
        T(2.28427405967365704), T(2.25905957386533007), T(2.23468639558705728), T(2.21108140887472837),
        T(2.18818043207202084), T(2.16592679374484121), T(2.14427018235626177), T(2.1231657086697906),
        T(2.10257313518499966), T(2.08245623798772517), T(2.0627822745039639), T(2.04352153665067027),
        T(2.02464697337293442), T(2.00613386995896725), T(1.98795957412306135), T(1.97010326084971399),
        T(1.9525457295488895), T(1.93526922829190084), T(1.91825730085973256), T(1.90149465310031829),
        T(1.88496703570286983), T(1.86866114098954261), T(1.85256451172308778), T(1.83666546025338473),
        T(1.82095299659100562), T(1.80541676421404929), T(1.79004698259461947), T(1.77483439558076972),
        T(1.7597702248942324), T(1.74484612810837714), T(1.73005416055824424), T(1.71538674070811714),
        T(1.70083661856430157), T(1.68639684677348689), T(1.67206075409185284), T(1.65782192094820813),
        T(1.64367415685698326), T(1.62961147946467899), T(1.61562809503713356), T(1.6017183802152779),
        T(1.5878768648844015), T(1.57409821601675048), T(1.56037722235984133), T(1.54670877985350419),
        T(1.53308787766755672), T(1.51950958475937159), T(1.50596903685655104), T(1.49246142377461632),
        T(1.47898197698309875), T(1.46552595733579549), T(1.45208864288221728), T(1.43866531667746189),
        T(1.4252512545068623), T(1.41184171243976109), T(1.39843191412360701), T(1.38501703772514939),
        T(1.3715922024197329), T(1.35815245432242371), T(1.3446927517457139), T(1.33120794965767741),
        T(1.31769278320134386), T(1.30414185012042227), T(1.29054959191787399), T(1.27691027355170061),
        T(1.26321796144602927), T(1.24946649956433475), T(1.23564948325448198), T(1.22176023053096339),
        T(1.20779175040675857), T(1.19373670782377306), T(1.17958738465446178), T(1.16533563615504776),
        T(1.1509728421389771), T(1.1364898520030764), T(1.12187692257225491), T(1.1071236475235362),
        T(1.09221887689655461), T(1.07715062488193869), T(1.06190596368362034), T(1.0464709007525812),
        T(1.03083023605645652), T(1.01496739523930057), T(0.998864233480644681), T(0.982500803502761477),
        T(0.965855079388131865), T(0.948902625497913155), T(0.931616196601354973), T(0.913965251008802881),
        T(0.895915352566239664), T(0.877427429097716982), T(0.858456843178052043), T(0.838952214281208697),
        T(0.818853906683319033), T(0.798092060626276134), T(0.776583987876149906), T(0.754230664434511699),
        T(0.730911910621882877), T(0.706479611313609812), T(0.680747918645906114), T(0.653478638715044413),
        T(0.62435859730909038), T(0.592962942441980445), T(0.558692178375520654), T(0.520656038725148096),
        T(0.477437837253791464), T(0.426547986303309479), T(0.362871431028424229), T(0.272320864704672982),
        T(8.56006539842194211e-08)
    };
}

#undef ZIGGURAT_LIKELY
#undef ZIGGURAT_NOINLINE

//------------------------------------------------------------------------------
// md/basic_types.hpp
//------------------------------------------------------------------------------

// This module defines basic typedefs used across micromd library.

#include <cstddef>
#include <cstdint>


namespace md
{
    // index is the integral type used to index arrays.
    using index = std::size_t;

    // scalar is the floating-point type of choice.
    using scalar = double;

    // step is the integral type used to count simulation steps.
    using step = std::int64_t;

    // random_engine is the default random engine used in micromd library.
    using random_engine = md::sfc64;

    // normal_distribution<T> is the distribution class used to generate normal
    // random numbers.
    template<typename T>
    using normal_distribution = md::ziggurat_normal_distribution<T>;

    // NOTE: Use of sfc64 and ziggurat algorithms significantly improves
    // performance (~20% speedup for brownian dynamics simulations).
}

//------------------------------------------------------------------------------
// md/forcefield.hpp
//------------------------------------------------------------------------------

// This module defines the interface of forcefield implementations.


namespace md
{
    class system;

    // forcefield is an abstract base class of forcefield classes.
    //
    // A forcefield class computes potential energy and forces acting on the
    // particles in a system.
    class forcefield
    {
    public:
        virtual ~forcefield() = default;

        // compute_energy computes the total potential energy of the system for
        // this forcefield.
        virtual md::scalar compute_energy(md::system const& system) = 0;

        // compute_force computes forces acting on each particle in the system
        // and adds (not assigns) force vectors to given array.
        virtual void compute_force(md::system const& system, md::array_view<md::vector> forces) = 0;
    };
}

//------------------------------------------------------------------------------
// md/system/attribute.hpp
//------------------------------------------------------------------------------

// This module defines the basics of the attribute mechanism implemented in the
// system class.
//
// Here the C++ type system is abused: An attribute is completely described by
// a function pointer:
//
//     T(* attribute)(Tag*).
//
// The return type T is used as the type of attribute values. And the dummy
// parameter type Tag, which is supposed to be a unique struct, is used to
// identify the attribute.

#include <memory>
#include <unordered_map>
#include <utility>
#include <vector>


namespace md
{
    // attribute_key is a type used to statically index system attribute. T is
    // the type of attribute values and Tag is a unique tag type.
    template<typename T, typename Tag = T>
    using attribute_key = T(*)(Tag*);

    // default_value returns the default value associated with given key.
    template<typename T, typename Tag>
    constexpr T default_value(md::attribute_key<T, Tag> key)
    {
        return key ? key(nullptr) : T{};
    }
}

//------------------------------------------------------------------------------
// md/system/particle.hpp
//------------------------------------------------------------------------------

// This module defines convenience classes used to access particles in a system.

#include <cstddef>
#include <iterator>


namespace md
{
    class system;

    // particle_ref provides mutable access to the attributes of a particle in a
    // system.
    struct particle_ref
    {
        md::index index;

        md::scalar& mass;
        md::scalar& mobility;
        md::point& position;
        md::vector& velocity;

        particle_ref(md::system& system, md::index idx);
    };

    // particle_iterator is a forward iterator that scans particles in a system.
    class particle_iterator
    {
    public:
        using value_type = md::particle_ref;
        using reference = md::particle_ref;
        using pointer = void;
        using difference_type = std::ptrdiff_t;
        using iterator_category = std::forward_iterator_tag;

        particle_iterator() = default;

        // Constructor takes a system and the index of the particle pointed to
        // by the constructed iterator.
        particle_iterator(md::system& system, md::index idx)
            : system_{&system}, index_{idx}
        {
        }

        // oeprator== compares the index for equality.
        bool operator==(particle_iterator const& other) const
        {
            return index_ == other.index_;
        }

        // operator!= compares the index for inequality.
        bool operator!=(particle_iterator const& other) const
        {
            return !(*this == other);
        }

        // operator* returns a particle_ref for the particle pointed-to by this
        // iterator.
        md::particle_ref operator*() const
        {
            return md::particle_ref(*system_, index_);
        }

        // operator++ increments the index.
        particle_iterator operator++(int)
        {
            auto copy = *this;
            ++*this;
            return copy;
        }

        // operator++ increments the index.
        particle_iterator& operator++()
        {
            index_++;
            return *this;
        }

    private:
        md::system* system_ = nullptr;
        md::index index_ = 0;
    };
}

//------------------------------------------------------------------------------
// md/system/detail/array_erasure.hpp
//------------------------------------------------------------------------------

// This module provides a type erasure for resizable arrays. The class is used
// by attribute_table to store differently typed arrays (columns).

#include <cassert>
#include <cstddef>
#include <memory>
#include <vector>


namespace md
{
    namespace detail
    {
        // array_erasure is a type erasure for resizable arrays.
        class array_erasure
        {
        private:
            array_erasure() = default;

        public:
            virtual ~array_erasure() = default;

            // size returns the length of the array.
            virtual std::size_t size() const = 0;

            // resize extends or shrinks the array to given length.
            virtual void resize(std::size_t size) = 0;

            // instance is the only allowed implementation of array_erasure.
            template<typename T>
            class instance;

            // make returns a unique_ptr of newly constructed instance<T>.
            template<typename T>
            static std::unique_ptr<instance<T>> make(std::size_t size, T def)
            {
                return std::unique_ptr<instance<T>>{new instance<T>(size, def)};
            }

            // recover returns a reference to the erased instance<T>. Behavior
            // is undefined if the actual type is not T.
            template<typename T>
            instance<T>& recover()
            {
                return static_cast<instance<T>&>(*this);
            }
        };

        template<typename T>
        class array_erasure::instance : public array_erasure
        {
        public:
            // Constructor takes the initial size of an array and the default
            // value used to create new elements.
            instance(std::size_t size, T def)
                : values_(size, def), default_{def}
            {
            }

            // data returns the pointer to the first element of the array.
            T* data()
            {
                return values_.data();
            }

            // size returns the length of the array.
            std::size_t size() const override
            {
                return values_.size();
            }

            // resize extends or shrinks the array to given length. New elements
            // are initialized with the default value.
            void resize(std::size_t size) override
            {
                values_.resize(size, default_);
            }

        private:
            std::vector<T> values_;
            T default_;
        };
    }
}

//------------------------------------------------------------------------------
// md/system/detail/attribute_table.hpp
//------------------------------------------------------------------------------

// This module defines attribute_table class: A data structure like a columnar
// database (or a dataframe), keyed by attribute_keys.

#include <memory>
#include <unordered_map>
#include <utility>
#include <vector>


namespace md
{
    namespace detail
    {
        using type_hash_t = void const*;

        // type_hash assigns a unique value for each given type.
        template<typename Tag>
        inline type_hash_t type_hash() noexcept
        {
            static char dummy;
            return &dummy;
        }

        // attribute_table is a table of arrays (columns) of the same length.
        // Each column is keyed by a tag type.
        class attribute_table
        {
        public:
            // size returns the number of elements in the columns.
            md::index size() const
            {
                return size_;
            }

            // resize resizes all the columns to the given size.
            void resize(md::index size)
            {
                for (auto& node : arrays_) {
                    node.second->resize(size);
                }
                size_ = size;
            }

            // require creates a column for given key if it does not exist. It
            // does nothing otherwise.
            template<typename T, typename Tag>
            void require(md::attribute_key<T, Tag> key)
            {
                type_hash_t const tag_key = type_hash<Tag>();

                if (arrays_.find(tag_key) == arrays_.end()) {
                    arrays_.emplace(
                        tag_key,
                        detail::array_erasure::make<T>(size_, md::default_value(key))
                    );
                }
            }

            // view returns a mutable view into the column with given key.
            template<typename T, typename Tag>
            md::array_view<T> view(md::attribute_key<T, Tag>)
            {
                return arrays_.at(type_hash<Tag>())->template recover<T>();
            }

            template<typename T, typename Tag>
            md::array_view<T const> view(md::attribute_key<T, Tag>) const
            {
                return arrays_.at(type_hash<Tag>())->template recover<T>();
            }

        private:
            md::index size_ = 0;
            std::unordered_map<type_hash_t, std::unique_ptr<detail::array_erasure>> arrays_;
        };
    }
}

//------------------------------------------------------------------------------
// md/system/detail/iterator_range.hpp
//------------------------------------------------------------------------------

// This module provides a basic class for adapting iterator pair as a range.

namespace md
{
    namespace detail
    {
        // iterator_range is a basic range adaptor for existing iterator.
        template<typename Iterator>
        class iterator_range
        {
        public:
            iterator_range(Iterator begin, Iterator end)
                : begin_{begin}, end_{end}
            {
            }

            Iterator begin() const
            {
                return begin_;
            }

            Iterator end() const
            {
                return end_;
            }

        private:
            Iterator begin_;
            Iterator end_;
        };
    }
}

//------------------------------------------------------------------------------
// md/system/detail/sum_forcefield.hpp
//------------------------------------------------------------------------------

// This class provides a forcefield implementation that combines one or more
// forcefields into a simple summation of them.

#include <cassert>
#include <memory>
#include <vector>


namespace md
{
    class system;

    namespace detail
    {
        // sum_forcefield is a forcefield implementation that compute the sum of
        // other forcefield instances.
        class sum_forcefield : public md::forcefield
        {
        public:
            // add adds a forcefield instance to the sum.
            void add(std::shared_ptr<md::forcefield> ff)
            {
                assert(ff);
                components_.push_back(ff);
            }

            // compute_energy implements md::forcefield.
            md::scalar compute_energy(md::system const& system) override
            {
                md::scalar sum = 0;

                for (std::shared_ptr<md::forcefield>& component : components_) {
                    sum += component->compute_energy(system);
                }
                return sum;
            }

            // compute_force implements md::forcefield.
            void compute_force(md::system const& system, md::array_view<md::vector> forces) override
            {
                for (std::shared_ptr<md::forcefield>& component : components_) {
                    component->compute_force(system, forces);
                }
            }

        private:
            std::vector<std::shared_ptr<md::forcefield>> components_;
        };
    }
}

//------------------------------------------------------------------------------
// md/system.hpp
//------------------------------------------------------------------------------

// This module defines the system class: A context class holding all particle
// parameters and state variables.

#include <algorithm>
#include <cstddef>
#include <iterator>
#include <memory>
#include <type_traits>


namespace md
{
    // mass_attribute is an attribute key for particle mass. The default value
    // is 1.
    inline constexpr md::scalar mass_attribute(struct tag_mass_attribute*)
    {
        return 1;
    }

    // mobility_attribute is an attribute key for particle mobility. This is
    // used in brownian dynamics simulations. The default value is 1.
    inline constexpr md::scalar mobility_attribute(struct tag_mobility_attribute*)
    {
        return 1;
    }

    // position_attribute is an attribute key for particle position. The default
    // value is the origin.
    inline constexpr md::point position_attribute(struct tag_position_attribute*)
    {
        return {};
    }

    // velocity_attribute is an attribute key for particle velocity. The default
    // value is the zero vector.
    inline constexpr md::vector velocity_attribute(struct tag_velocity_attribute*)
    {
        return {};
    }

    // basic_particle_data holds basic particle attribute values. It is used to
    // pass these data to system::add_particle function.
    struct basic_particle_data
    {
        md::scalar mass = md::default_value(md::mass_attribute);
        md::scalar mobility = md::default_value(md::mobility_attribute);
        md::point position = md::default_value(md::position_attribute);
        md::vector velocity = md::default_value(md::velocity_attribute);
    };

    // system is a context class.
    class system
    {
    public:
        system()
        {
            require(md::mass_attribute);
            require(md::mobility_attribute);
            require(md::position_attribute);
            require(md::velocity_attribute);
        }

        // add_particle adds a particle to the system.
        md::particle_ref add_particle(md::basic_particle_data data = {})
        {
            md::index const idx = attributes_.size();

            attributes_.resize(idx + 1);

            view_masses()[idx] = data.mass;
            view_mobilities()[idx] = data.mobility;
            view_positions()[idx] = data.position;
            view_velocities()[idx] = data.velocity;

            return md::particle_ref(*this, idx);
        }

        // particles returns a range for iterating over particles in the system.
        detail::iterator_range<md::particle_iterator> particles()
        {
            return detail::iterator_range<md::particle_iterator>{
                md::particle_iterator{*this, 0},
                md::particle_iterator{*this, particle_count()},
            };
        }

        // particle_count returns the number of particles in the system.
        md::index particle_count() const
        {
            return attributes_.size();
        }

        // require creates a particle attribute if it does not exist.
        template<typename T, typename Tag>
        void require(md::attribute_key<T, Tag> key)
        {
            attributes_.require(key);
        }

        // view returns a view into the array of particle attribute values.
        template<typename T, typename Tag>
        md::array_view<T> view(md::attribute_key<T, Tag> key)
        {
            return attributes_.view(key);
        }

        template<typename T, typename Tag>
        md::array_view<T const> view(md::attribute_key<T, Tag> key) const
        {
            return attributes_.view(key);
        }

        // view_masses returns a view of built-in mass attributes.
        md::array_view<md::scalar> view_masses() noexcept
        {
            return attributes_.view(md::mass_attribute);
        }

        md::array_view<md::scalar const> view_masses() const noexcept
        {
            return attributes_.view(md::mass_attribute);
        }

        // view_mobilities returns a view of built-in mobility attributes.
        md::array_view<md::scalar> view_mobilities() noexcept
        {
            return attributes_.view(md::mobility_attribute);
        }

        md::array_view<md::scalar const> view_mobilities() const noexcept
        {
            return attributes_.view(md::mobility_attribute);
        }

        // view_positions returns a view of built-in position attributes.
        md::array_view<md::point> view_positions() noexcept
        {
            return attributes_.view(md::position_attribute);
        }

        md::array_view<md::point const> view_positions() const noexcept
        {
            return attributes_.view(md::position_attribute);
        }

        // view_velocities returns a view of built-in velocity attributes.
        md::array_view<md::vector> view_velocities() noexcept
        {
            return attributes_.view(md::velocity_attribute);
        }

        md::array_view<md::vector const> view_velocities() const noexcept
        {
            return attributes_.view(md::velocity_attribute);
        }

        // add_forcefield adds a forcefield to the system.
        //
        // With this overload the added forcefield is shared between the caller.
        // So the added forcefield can be modified from outside.
        void add_forcefield(std::shared_ptr<md::forcefield> ff)
        {
            forcefield_.add(ff);
        }

        // add_forcefield adds a copy of passed forcefield to the system.
        //
        // This overload returns a new shared_ptr holding the copy of the passed
        // forcefield. The forcefield can be modified via the returned pointer.
        template<
            typename FF,
            typename = typename std::enable_if<std::is_base_of<md::forcefield, FF>::value>::type
        >
        std::shared_ptr<FF> add_forcefield(FF const& ff)
        {
            std::shared_ptr<FF> ffptr = std::make_shared<FF>(ff);
            add_forcefield(ffptr);
            return ffptr;
        }

        // compute_kinetic_energy returns the total kinetic energy of the
        // system. It uses mass and velocity particle attributes.
        md::scalar compute_kinetic_energy() const
        {
            md::array_view<md::scalar const> masses = view_masses();
            md::array_view<md::vector const> velocities = view_velocities();

            md::scalar sum = 0;

            for (md::index i = 0; i < particle_count(); i++) {
                sum += 0.5 * masses[i] * velocities[i].squared_norm();
            }

            return sum;
        }

        // compute_potential_energy returns the total potential energy of the
        // system. This function is not marked const because forcefield may
        // mutate its state when computing energy.
        md::scalar compute_potential_energy()
        {
            return forcefield_.compute_energy(*this);
        }

        // compute_energy returns the total mechanical energy of the system.
        // Mechanical energy is the sum of kinetic energy and potential energy.
        md::scalar compute_energy()
        {
            return compute_kinetic_energy() + compute_potential_energy();
        }

        // compute_force assigns total force acting on each particle to given
        // forces array. The length of the array must be the same as the number
        // of particles in the system.
        void compute_force(md::array_view<md::vector> forces)
        {
            assert(forces.size() == particle_count());

            md::vector const zero {};
            std::fill(forces.begin(), forces.end(), zero);

            forcefield_.compute_force(*this, forces);
        }

    private:
        detail::attribute_table attributes_;
        detail::sum_forcefield forcefield_;
    };

    inline md::particle_ref::particle_ref(md::system& system, md::index idx)
        : index{idx}
        , mass{system.view_masses()[idx]}
        , mobility{system.view_mobilities()[idx]}
        , position{system.view_positions()[idx]}
        , velocity{system.view_velocities()[idx]}
    {
    }
}

//------------------------------------------------------------------------------
// md/potential/constant_potential.hpp
//------------------------------------------------------------------------------

// This module provides constant_potential. Used as defaults and in tests.


namespace md
{
    // constant_potential is a fixed-value potential energy function:
    //
    //     u(r) = e ,
    //     F(r) = 0 .
    //
    struct constant_potential
    {
        // The constant energy value.
        md::scalar energy = 0;

        md::scalar evaluate_energy(md::vector) const
        {
            return energy;
        }

        md::vector evaluate_force(md::vector) const
        {
            return {};
        }
    };
}

//------------------------------------------------------------------------------
// md/potential/cosine_bending_potential.hpp
//------------------------------------------------------------------------------

// This module provides the cosine bending potential.

#include <cmath>
#include <tuple>


namespace md
{
    // cosine_bending_potential implements the three-body bending potential
    // function:
    //
    //     u(r,s) = e dot(r,s) / |r||s|
    //
    struct cosine_bending_potential
    {
        md::scalar bending_energy = 0;

        md::scalar evaluate_energy(md::vector rij, md::vector rjk) const
        {
            md::scalar const dij_sq = rij.squared_norm();
            md::scalar const djk_sq = rjk.squared_norm();

            if (dij_sq * djk_sq == 0) {
                return 0;
            }

            md::scalar const dot_ijk = md::dot(rij, rjk);
            md::scalar const dij_djk = std::sqrt(dij_sq * djk_sq);
            md::scalar const cos_ijk = dot_ijk / dij_djk;

            return bending_energy - bending_energy * cos_ijk;
        }

        std::tuple<md::vector, md::vector, md::vector> evaluate_force(
            md::vector rij, md::vector rjk
        ) const
        {
            md::scalar const dij_sq = rij.squared_norm();
            md::scalar const djk_sq = rjk.squared_norm();
            md::scalar const dij_djk = std::sqrt(dij_sq * djk_sq);

            if (dij_djk == 0) {
                return std::make_tuple(md::vector{}, md::vector{}, md::vector{});
            }

            md::scalar const dot_ijk = md::dot(rij, rjk);
            md::scalar const e_div_dd = bending_energy / dij_djk;
            md::vector const fij = e_div_dd * (rjk - dot_ijk / dij_sq * rij);
            md::vector const fjk = e_div_dd * (rij - dot_ijk / djk_sq * rjk);

            return std::make_tuple(fij, fjk - fij, -fjk);
        }
    };
}

//------------------------------------------------------------------------------
// md/potential/harmonic_potential.hpp
//------------------------------------------------------------------------------

// This module provides the harmonic potential.


namespace md
{
    // harmonic_potential implements the centered harmonic potential function:
    //
    //     u(r) = K/2 r^2 ,
    //     F(r) = -K r .
    //
    struct harmonic_potential
    {
        // The spring constant K.
        md::scalar spring_constant = 1;

        md::scalar evaluate_energy(md::vector r) const
        {
            return 0.5 * spring_constant * r.squared_norm();
        }

        md::vector evaluate_force(md::vector r) const
        {
            return -spring_constant * r;
        }
    };
}

//------------------------------------------------------------------------------
// md/potential/lennard_jones_potential.hpp
//------------------------------------------------------------------------------

// This module provides the Lennard-Jones potential.


namespace md
{
    // lennard_jones_potential implements the (12-6) Lennard-Jones potential
    // function:
    //
    //     u(r) = e ( (s/r)^12 - 2 (s/r)^6 ) ,
    //     F(r) = 12 e ( (s/r)^12 - (s/r)^6 ) r / r^2 .
    //
    // The potential energy takes its minimum value -e at r = s.
    struct lennard_jones_potential
    {
        // The enenrgy parameter e.
        md::scalar epsilon = 1;

        // The distance parameter s.
        md::scalar sigma = 1;

        md::scalar evaluate_energy(md::vector r) const
        {
            md::scalar const u2 = sigma * sigma / r.squared_norm();
            md::scalar const u6 = u2 * u2 * u2;

            return epsilon * (u6 * u6 - u6 - u6);
        }

        md::vector evaluate_force(md::vector r) const
        {
            md::scalar const r2_inv = 1 / r.squared_norm();
            md::scalar const u2 = sigma * sigma * r2_inv;
            md::scalar const u6 = u2 * u2 * u2;

            return 12 * epsilon * (u6 * u6 - u6) * r2_inv * r;
        }
    };
}

//------------------------------------------------------------------------------
// md/potential/soft_lennard_jones_potential.hpp
//------------------------------------------------------------------------------

// This module provides a soft variation of the Lennard-Jones potential.


namespace md
{
    // soft_lennard_jones_potential is a soft variation of the (12-6) Lennard-
    // Jones potential function:
    //
    //     u(r) = e ((k + 1)/(k + (r/s)^6) - 1)^2 .
    //
    // The parameter k controls the soft-ness of the repulsion:
    //
    //     u(0) = e/k^2 .
    //
    // The potential matches the LJ potential when k=0.
    struct soft_lennard_jones_potential
    {
        md::scalar epsilon = 1;
        md::scalar sigma = 1;
        md::scalar softness = 0.1;

        md::scalar evaluate_energy(md::vector r) const
        {
            md::scalar const u2 = r.squared_norm() / (sigma * sigma);
            md::scalar const u6 = u2 * u2 * u2;
            md::scalar const g = (softness + 1) / (softness + u6) - 1;
            return epsilon * g * g;
        }

        md::vector evaluate_force(md::vector r) const
        {
            md::scalar const sigma_inv2 = 1 / (sigma * sigma);
            md::scalar const u2 = r.squared_norm() * sigma_inv2;
            md::scalar const u4 = u2 * u2;
            md::scalar const u6 = u4 * u2;
            md::scalar const g = (softness + 1) / (softness + u6);
            return 12 * epsilon * sigma_inv2 * u4 * (g * g - g) * r;
        }
    };
}

//------------------------------------------------------------------------------
// md/potential/softcore_potential.hpp
//------------------------------------------------------------------------------

// This module provides a softcore short-range potential.


namespace md
{
    namespace detail
    {
        inline md::scalar power(md::scalar x, int n)
        {
            if (n == 0) {
                return 1;
            }

            md::scalar pow = x;
            for (int i = 1; i < n; i++) {
                pow *= x;
            }
            return pow;
        }
    }

    // softcore_potential implements the following bell-shaped short-range
    // potential energy function:
    //
    //     u(r) = e ( 1 - (r/s)^2 )^N               (r < s)
    //     F(r) = 2Ne/s^2 ( 1 - (r/s)^2 )^(N-1) r   (r < s)
    //
    // The potential energy is constantly zero at and beyond r = s.
    //
    // This function approximates the gaussian function
    //
    //    u(r) = e exp(- r^2 / (2 sigma^2) )
    //
    // when s = sqrt(2N) sigma and N is large.
    template<int N>
    struct softcore_potential
    {
        static_assert(N >= 1, "softcore_potential exponent must be positive");

        // The energy parameter e.
        md::scalar overlap_energy = 1;

        // The distance parameter s.
        md::scalar cutoff_distance = 1;


        md::scalar evaluate_energy(md::vector r) const
        {
            md::scalar const k2 = 1 / (cutoff_distance * cutoff_distance);
            md::scalar const u2 = k2 * r.squared_norm();
            md::scalar const g = 1 - u2;

            if (g < 0) {
                return 0;
            }

            return overlap_energy * detail::power(g, N);
        }

        md::vector evaluate_force(md::vector r) const
        {
            md::scalar const k2 = 1 / (cutoff_distance * cutoff_distance);
            md::scalar const u2 = k2 * r.squared_norm();
            md::scalar const g = 1 - u2;

            if (g < 0) {
                return {};
            }

            return 2 * N * overlap_energy * k2 * detail::power(g, N - 1) * r;
        }
    };
}

//------------------------------------------------------------------------------
// md/potential/spring_potential.hpp
//------------------------------------------------------------------------------

// This module provides harmonic potential with nonzero equilibriums distance.


namespace md
{
    // spring_potential implements harmonic spring potential function:
    //
    //     u(r) = K/2 (r - b)^2 ,
    //     F(r) = -K (r - b)/r r .
    //
    // b is the equilibrium distance.
    struct spring_potential
    {
        md::scalar spring_constant = 1;
        md::scalar equilibrium_distance = 0;

        md::scalar evaluate_energy(md::vector r) const
        {
            md::scalar const u = r.norm() - equilibrium_distance;
            return 0.5 * spring_constant * u * u;
        }

        md::vector evaluate_force(md::vector r) const
        {
            md::scalar const r1 = r.norm();
            if (r1 == 0) {
                return md::vector{};
            }
            return (spring_constant * equilibrium_distance / r1 - spring_constant) * r;
        }
    };
}

//------------------------------------------------------------------------------
// md/forcefield/detail/pair_potfun.hpp
//------------------------------------------------------------------------------

// This module implements a internal utility to normalize pair potential functor
// into a potential functor factory. Used by make_* family of functions.

#include <utility>


namespace md
{
    namespace detail
    {
        template<typename P>
        struct pair_potential_factory
        {
            P potential;

            inline P operator()(md::index, md::index) const
            {
                return potential;
            }
        };

        template<
            typename PotFun,
            typename = decltype(std::declval<PotFun>()(md::index{}, md::index{}))
        >
        PotFun make_pair_potfun(PotFun potfun)
        {
            return potfun;
        }

        template<typename P, typename... Dummy>
        pair_potential_factory<P> make_pair_potfun(P pot, Dummy...)
        {
            return pair_potential_factory<P>{pot};
        }
    }
}

//------------------------------------------------------------------------------
// md/forcefield/all_pair_forcefield.hpp
//------------------------------------------------------------------------------

// This module provides a template forcefield implementation that computes
// interactions between all particle pairs.

#include <type_traits>
#include <utility>


namespace md
{
    // all_pair_forcefield implements md::forcefield. It computes interactions
    // between every pair of particles.
    //
    // This is a CRTP base class. Derived class must define a callback:
    //
    //     auto all_pair_potential(
    //         md::system const& system,
    //         md::index i,
    //         md::index j
    //     )
    //     Returns the potential object for (i,j) pair.
    //
    template<typename Derived>
    class all_pair_forcefield : public virtual md::forcefield
    {
    public:
        // compute_energy implements md::forcefield.
        md::scalar compute_energy(md::system const& system) override
        {
            md::array_view<md::point const> positions = system.view_positions();
            md::scalar sum = 0;

            for (md::index j = 0; j < positions.size(); j++) {
                for (md::index i = 0; i < j; i++) {
                    auto const pot = derived().all_pair_potential(system, i, j);
                    auto const r = positions[i] - positions[j];

                    sum += pot.evaluate_energy(r);
                }
            }

            return sum;
        }

        // compute_force implements md::forcefield.
        void compute_force(md::system const& system, md::array_view<md::vector> forces) override
        {
            md::array_view<md::point const> positions = system.view_positions();

            for (md::index j = 0; j < positions.size(); j++) {
                for (md::index i = 0; i < j; i++) {
                    auto const pot = derived().all_pair_potential(system, i, j);
                    auto const r = positions[i] - positions[j];

                    auto const force = pot.evaluate_force(r);
                    forces[i] += force;
                    forces[j] -= force;
                }
            }
        }

    private:
        // derived returns a reference to this object as the CRTP derived class.
        Derived& derived()
        {
            return static_cast<Derived&>(*this);
        }
    };

    template<typename PotFun>
    class basic_all_pair_forcefield
        : public md::all_pair_forcefield<basic_all_pair_forcefield<PotFun>>
    {
    public:
        explicit basic_all_pair_forcefield(PotFun potfun)
            : potfun_{potfun}
        {
        }

        auto all_pair_potential(md::system const&, md::index i, md::index j) const
        {
            return potfun_(i, j);
        }

    private:
        PotFun potfun_;
    };

    // make_all_pair_forcefield implements md::all_pair_forcefield with given
    // potential object or lambda returning a potential object.
    template<typename P>
    auto make_all_pair_forcefield(P pot)
    {
        auto potfun = detail::make_pair_potfun(pot);
        using potfun_type = decltype(potfun);
        return md::basic_all_pair_forcefield<potfun_type>{potfun};
    }
}

//------------------------------------------------------------------------------
// md/forcefield/composite_forcefield.hpp
//------------------------------------------------------------------------------

// This module provides a template forcefield implementation that statically
// combines multiple forcefields into a single sum forcefield.

#include <iterator>
#include <numeric>


namespace md
{
    // composite_forcefield implements md::forcefield as a sum of zero or more
    // forcefield implementations given by the template parameter.
    //
    // Due to diamond inheritance the components must derive md::forcefield with
    // `virtual` keyword.
    template<typename... Components>
    class composite_forcefield : public virtual md::forcefield, public Components...
    {
    public:
        // compute_energy implements md::forcefield.
        md::scalar compute_energy(md::system const& system) override
        {
            (void) system;

            md::scalar energies[] = {
                0,
                Components::compute_energy(system)...
            };
            return std::accumulate(std::begin(energies), std::end(energies), md::scalar(0));
        }

        // compute_force implements md::forcefield.
        void compute_force(md::system const& system, md::array_view<md::vector> forces) override
        {
            int dummy[] = {
                0,
                (Components::compute_force(system, forces), 0)...
            };
            (void) dummy;
            (void) system;
            (void) forces;
        }
    };
}

//------------------------------------------------------------------------------
// md/forcefield/detail/field_potfun.hpp
//------------------------------------------------------------------------------

// This module implements an internal utility to normalize field potential
// functor into a potential functor factory. Used by make_* family of functions.

#include <utility>


namespace md
{
    namespace detail
    {
        template<typename P>
        struct field_potential_factory
        {
            P potential;

            inline P operator()(md::index) const
            {
                return potential;
            }
        };

        template<
            typename PotFun,
            typename = decltype(std::declval<PotFun>()(md::index{}, md::index{}))
        >
        PotFun make_field_potfun(PotFun potfun)
        {
            return potfun;
        }

        template<typename P, typename... Dummy>
        field_potential_factory<P> make_field_potfun(P pot, Dummy...)
        {
            return field_potential_factory<P>{pot};
        }
    }
}

//------------------------------------------------------------------------------
// md/forcefield/ellipsoid_surface_forcefield.hpp
//------------------------------------------------------------------------------

// This module provides a template forcefield implementation that computes
// field force acting on particles near an ellipsoidal surface.


namespace md
{
    // ellipsoid is a triaxial ellipsoid.
    struct ellipsoid
    {
        // Center of the ellipsoid. Defaults to the origin.
        md::point center;

        // Semiaxis lengths along the coordinate axes. Defaults to 1.
        md::scalar semiaxis_x = 1;
        md::scalar semiaxis_y = 1;
        md::scalar semiaxis_z = 1;

        // implicit returns the implicit ellipsoid function evaluated at pt:
        // f(x,y,z) = (x/a)^2 + (y/b)^2 + (z/c)^2 - 1.
        md::scalar implicit(md::point pt) const
        {
            md::vector const quadform = {
                1 / (semiaxis_x * semiaxis_x),
                1 / (semiaxis_y * semiaxis_y),
                1 / (semiaxis_z * semiaxis_z)
            };
            md::vector const r = pt - center;

            return quadform.hadamard(r).dot(r) - 1;
        }
    };

    namespace detail
    {
        // ellipsoid_eval holds mathematical quantities required to compute the
        // gradient of surface potential on a given point.
        struct ellipsoid_eval
        {
            // True if the point is at the center. Other members are undefined
            // if this flag is true.
            bool undefined;

            // Vector pointing to the point from an estimated nearest point on
            // the ellipsoid.
            md::vector delta;

            // Some vector needed to transform a gradient.
            md::vector strain;

            // The value of the implicit function defining the ellipsoid.
            md::scalar implicit;
        };

        inline detail::ellipsoid_eval evaluate_point(md::ellipsoid ellip, md::point pt)
        {
            md::vector const quadform = {
                1 / (ellip.semiaxis_x * ellip.semiaxis_x),
                1 / (ellip.semiaxis_y * ellip.semiaxis_y),
                1 / (ellip.semiaxis_z * ellip.semiaxis_z)
            };

            md::vector const radial = pt - ellip.center;
            md::vector const dual = quadform.hadamard(radial);

            if (dual.squared_norm() == 0) {
                detail::ellipsoid_eval ev;
                ev.undefined = true;
                return ev;
            }

            md::scalar const implicit = dual.dot(radial) - 1;
            md::scalar const scale = implicit / (2 * dual.squared_norm());

            detail::ellipsoid_eval ev;

            ev.undefined = false;
            ev.delta = scale * dual;
            ev.strain = scale * quadform;
            ev.implicit = implicit;

            return ev;
        }
    }

    // ellipsoid_surface_forcefield computes short-range field interaction of
    // particles and an ellipsoidal surface. It uses an approximation and so
    // computed interactions are inaccurate near the center.
    //
    // This is a CRTP base class. Callbacks are:
    //
    //     auto ellipsoid_inward_potential(
    //         md::system const& system,
    //         md::index i
    //     )
    //     Returns the potential object for a particle inside ellipsoid. It
    //     defaults to a zero potential if not defined.
    //
    //     auto ellipsoid_outward_potential(
    //         md::system const& system,
    //         md::index i
    //     )
    //     Returns the potential object for a particle outside ellipsoid. It
    //     defaults to a zero potential if not defined.
    //
    template<typename Derived>
    class ellipsoid_surface_forcefield : public virtual md::forcefield
    {
    public:
        // set_ellipsoid changes the ellipsoid to given one.
        Derived& set_ellipsoid(md::ellipsoid ellip)
        {
            ellipsoid_ = ellip;
            return derived();
        }

        // compute_energy implements md::forcefield.
        md::scalar compute_energy(md::system const& system) override
        {
            md::array_view<md::point const> positions = system.view_positions();

            md::scalar sum = 0;

            for (md::index i = 0; i < system.particle_count(); i++) {
                detail::ellipsoid_eval const ev = detail::evaluate_point(ellipsoid_, positions[i]);

                if (ev.undefined) {
                    continue;
                }

                if (ev.implicit < 0) {
                    sum += derived()
                        .ellipsoid_inward_potential(system, i)
                        .evaluate_energy(ev.delta);
                } else {
                    sum += derived()
                        .ellipsoid_outward_potential(system, i)
                        .evaluate_energy(ev.delta);
                }
            }

            return sum;
        }

        // compute_force implements md::forcefield.
        void compute_force(md::system const& system, md::array_view<md::vector> forces) override
        {
            md::array_view<md::point const> positions = system.view_positions();

            for (md::index i = 0; i < system.particle_count(); i++) {
                detail::ellipsoid_eval const ev = detail::evaluate_point(ellipsoid_, positions[i]);

                if (ev.undefined) {
                    continue;
                }

                md::vector basic_force;

                if (ev.implicit < 0) {
                    basic_force = derived()
                        .ellipsoid_inward_potential(system, i)
                        .evaluate_force(ev.delta);
                } else {
                    basic_force = derived()
                        .ellipsoid_outward_potential(system, i)
                        .evaluate_force(ev.delta);
                }

                md::vector const iso_force = basic_force.project(ev.delta);
                md::vector const aniso_force = basic_force - iso_force;
                md::vector const strain_force = (aniso_force - iso_force).hadamard(ev.strain);
                md::vector const force = iso_force + strain_force;

                forces[i] += force;
            }
        }

        // ellipsoid_inward_potential by default returns a zero potential.
        md::constant_potential ellipsoid_inward_potential(md::system const&, md::index) const
        {
            return md::constant_potential{0};
        }

        // ellipsoid_outward_potential by default returns a zero potential.
        md::constant_potential ellipsoid_outward_potential(md::system const&, md::index) const
        {
            return md::constant_potential{0};
        }

    private:
        // derived returns a reference to this object as the CRTP derived class.
        Derived& derived()
        {
            return static_cast<Derived&>(*this);
        }

        md::ellipsoid ellipsoid_;
    };

    template<typename PotFun>
    class basic_ellipsoid_inward_forcefield
        : public md::ellipsoid_surface_forcefield<basic_ellipsoid_inward_forcefield<PotFun>>
    {
    public:
        explicit basic_ellipsoid_inward_forcefield(PotFun potfun)
            : potfun_{potfun}
        {
        }

        auto ellipsoid_inward_potential(md::system const&, md::index i) const
        {
            return potfun_(i);
        }

    private:
        PotFun potfun_;
    };

    template<typename PotFun>
    class basic_ellipsoid_outward_forcefield
        : public md::ellipsoid_surface_forcefield<basic_ellipsoid_outward_forcefield<PotFun>>
    {
    public:
        explicit basic_ellipsoid_outward_forcefield(PotFun potfun)
            : potfun_{potfun}
        {
        }

        auto ellipsoid_outward_potential(md::system const&, md::index i) const
        {
            return potfun_(i);
        }

    private:
        PotFun potfun_;
    };

    // make_ellipsoid_inward_forcefield implements
    // md::ellipsoid_surface_forcefield with given potential object or lambda
    // returning a potential object.
    template<typename P>
    auto make_ellipsoid_inward_forcefield(P pot)
    {
        auto potfun = detail::make_field_potfun(pot);
        using potfun_type = decltype(potfun);
        return md::basic_ellipsoid_inward_forcefield<potfun_type>{potfun};
    }

    // make_ellipsoid_outward_forcefield implements
    // md::ellipsoid_surface_forcefield with given potential object or lambda
    // returning a potential object.
    template<typename P>
    auto make_ellipsoid_outward_forcefield(P pot)
    {
        auto potfun = detail::make_field_potfun(pot);
        using potfun_type = decltype(potfun);
        return md::basic_ellipsoid_outward_forcefield<potfun_type>{potfun};
    }
}

//------------------------------------------------------------------------------
// md/misc/linear_hash.hpp
//------------------------------------------------------------------------------

// This module provides a functor class to linearly hash integral triples. Used
// to implement neighbor_searcher.

#include <cstdint>


namespace md
{
    // linear_hash is a linear hash function for integral triples. The following
    // equality holds for any linear_hash h:
    //
    //     h(x+dx, y+dy, z+dz) = h(x,y,z) + h(dx,dy,dz) .
    //
    struct linear_hash
    {
        using uint = std::uint32_t;

        // Hash coefficients. Default values are arbitrarily chosen primes.
        uint x_coeff = 3929498747;
        uint y_coeff = 1008281837;
        uint z_coeff = 1832832077;
        uint modulus = 1021;

        inline uint operator()(uint x, uint y, uint z) const
        {
            // Avoid 32-bit wraparound, which breaks linearity.
            using uint2x = std::uint64_t;

            uint2x sum = 0;
            sum += uint2x{x_coeff} * x;
            sum += uint2x{y_coeff} * y;
            sum += uint2x{z_coeff} * z;

            return uint(sum % modulus);
        }
    };
}

//------------------------------------------------------------------------------
// md/misc/neighbor_searcher.hpp
//------------------------------------------------------------------------------

// This module implements a time-efficient neighbor search algorithm in an open
// three-dimensional space.

#include <algorithm>
#include <set>
#include <utility>
#include <vector>


namespace md
{
    // neighbor_searcher implements a spatial hashing algorithm for efficiently
    // searching point cloud for neighboring pairs.
    class neighbor_searcher
    {
        using hash_type = md::linear_hash::uint;

    public:
        // Constructor takes the cut-off distance and a hash function to use.
        //
        // The modulus of the hash determines the number of buckets where points
        // are assigned. It cannot be zero.
        neighbor_searcher(md::scalar dcut, md::linear_hash hash)
            : dcut_{dcut}, hash_{hash}, buckets_(hash.modulus)
        {
            // Pre-compute neighborhood of each bucket for faster query.
            hash_type const coord_deltas[] = {
                hash.modulus - 1,
                hash.modulus,
                hash.modulus + 1
            };

            for (hash_type const dx : coord_deltas) {
                for (hash_type const dy : coord_deltas) {
                    for (hash_type const dz : coord_deltas) {
                        hash_deltas_.insert(hash_(dx, dy, dz));
                    }
                }
            }

            for (hash_type center = 0; center < hash.modulus; center++) {
                std::vector<md::index>& neighbors = buckets_[center].neighbors;

                for (hash_type const delta : hash_deltas_) {
                    hash_type const neighbor = (center + delta) % hash.modulus;

                    // Leverage symmetry to reduce search space.
                    if (neighbor >= center) {
                        neighbors.push_back(neighbor);
                    }
                }
            }
        }

        // set_points assigns given points to hash table for subsequent queries.
        void set_points(md::array_view<md::point const> points)
        {
            for (hash_bucket& bucket : buckets_) {
                bucket.members.clear();
            }

            for (md::index idx = 0; idx < points.size(); idx++) {
                md::point const pt = points[idx];
                hash_bucket& bucket = buckets_[locate_bucket(pt)];
                bucket.members.push_back({idx, pt});
            }
        }

        // search outputs pairs of indices of neighboring points to given output
        // iterator. Each index pair (i,j) satisfies i < j. No duplicates are
        // reported.
        template<typename OutputIterator>
        void search(OutputIterator out) const
        {
            for (hash_bucket const& center : buckets_) {
                for (md::index const neighbor : center.neighbors) {
                    search_among(center, buckets_[neighbor], out);
                }
            }
        }

        // query outputs the indices of points neighboring to given point.
        template<typename OutputIterator>
        void query(md::point point, OutputIterator out) const
        {
            hash_type const center_index = locate_bucket(point);
            md::scalar const dcut2 = dcut_ * dcut_;

            for (hash_type const delta : hash_deltas_) {
                hash_bucket const& bucket = buckets_[(center_index + delta) % hash_.modulus];

                for (hash_bucket::member member : bucket.members) {
                    if (md::squared_distance(member.point, point) < dcut2) {
                        *out++ = member.index;
                    }
                }
            }

        }

    private:
        // hash_bucket is a bucket in a spatial hash table.
        struct hash_bucket
        {
            struct member
            {
                md::index index;
                md::point point;
            };
            std::vector<member> members;
            std::vector<md::index> neighbors;
        };

        // search_among searches a pair of buckets for all neighboring pairs.
        template<typename OutputIterator>
        inline void search_among(
            hash_bucket const& bucket_a,
            hash_bucket const& bucket_b,
            OutputIterator& out
        ) const
        {
            md::scalar const dcut2 = dcut_ * dcut_;

            for (hash_bucket::member member_j : bucket_b.members) {
                for (hash_bucket::member member_i : bucket_a.members) {
                    if (member_i.index == member_j.index) {
                        // Avoid double counting when bucket_a == bucket_b.
                        break;
                    }

                    if (md::squared_distance(member_i.point, member_j.point) > dcut2) {
                        continue;
                    }

                    *out++ = std::make_pair(
                        std::min(member_i.index, member_j.index),
                        std::max(member_i.index, member_j.index)
                    );
                }
            }
        }

        // locate_bin returns the hash index for a point.
        inline hash_type locate_bucket(md::point pt) const
        {
            // Negative coordinate value causes discontinuous jumps in hash
            // value which breaks our search algorithm. Avoid that by
            // offsetting.
            constexpr md::scalar offset = 1L << 16;

            md::scalar const freq = 1 / dcut_;
            hash_type const x = hash_type(offset + freq * pt.x);
            hash_type const y = hash_type(offset + freq * pt.y);
            hash_type const z = hash_type(offset + freq * pt.z);

            return hash_(x, y, z);
        }

    private:
        md::scalar dcut_;
        md::linear_hash hash_;
        std::set<hash_type> hash_deltas_;
        std::vector<hash_bucket> buckets_;
    };
}

//------------------------------------------------------------------------------
// md/forcefield/detail/neighbor_list.hpp
//------------------------------------------------------------------------------

// This module provides neighbor_list: A data structure for tracking neighbor
// pairs in a system. Used to implement neighbor_pair_forcefield.

#include <algorithm>
#include <cmath>
#include <iterator>
#include <utility>
#include <vector>


namespace md
{
    namespace detail
    {
        // determine_hash returns a linear_hash object that is heuristically
        // parameterized to make neighbor_searcher perform good on given points.
        inline md::linear_hash determine_hash(
            md::array_view<md::point const> points,
            md::scalar dcut
        )
        {
            md::linear_hash hash;

            (void) dcut;

            // Benchmark simulations run fastest with this simple heuristic
            // among those I have tried.
            hash.modulus = md::linear_hash::uint(points.size() * 2 / 11);
            hash.modulus |= 1;

            return hash;
        }
    }

    // neighbor_list is a data structure for efficiently keeping track of
    // neighbor pairs in a slowly moving particle system.
    class neighbor_list
    {
        using iterator = std::vector<std::pair<md::index, md::index>>::const_iterator;

    public:
        // update rebuilds the neighbor list if necessary.
        void update(md::array_view<md::point const> points, md::scalar dcut)
        {
            if (!check_consistency(points, dcut)) {
                rebuild(points, dcut);
            }
        }

        // Range interface.
        iterator begin() const
        {
            return pairs_.begin();
        }

        iterator end() const
        {
            return pairs_.end();
        }

    private:
        // check_consistency checks if the cached neighbor list is still usable
        // with given points and cutoff distance.
        bool check_consistency(md::array_view<md::point const> points, md::scalar dcut) const
        {
            if (points.size() != cached_points_.size()) {
                return false;
            }

            // False negatives (unlisted point pairs that fall actually within
            // dcut) won't arise if the displacement from previous rebuild is
            // less than or equal to this threshold.
            md::scalar const threshold = (verlet_radius_ - dcut) / 2;

            if (threshold <= 0) {
                return false;
            }

            for (md::index i = 0; i < points.size(); i++) {
                if (md::squared_distance(points[i], cached_points_[i]) > threshold * threshold) {
                    return false;
                }
            }

            return true;
        }

        // rebuild completely rebuilds the neighbor list.
        void rebuild(md::array_view<md::point const> points, md::scalar dcut)
        {
            // Heuristic: 1.2 gives fairly good performance.
            constexpr md::scalar skin_factor = 1.2;

            verlet_radius_ = dcut * skin_factor;
            cached_points_.assign(points.begin(), points.end());
            pairs_.clear();

            md::linear_hash hash = detail::determine_hash(points, dcut);
            md::neighbor_searcher searcher{verlet_radius_, hash};
            searcher.set_points(cached_points_);
            searcher.search(std::back_inserter(pairs_));
        }

    private:
        md::scalar verlet_radius_ = 0;
        std::vector<md::point> cached_points_;
        std::vector<std::pair<md::index, md::index>> pairs_;
    };
}

//------------------------------------------------------------------------------
// md/forcefield/neighbor_pair_forcefield.hpp
//------------------------------------------------------------------------------

// This module provides a template forcefield implementation that computes
// short-range interactions between particles in a cutoff distance.

#include <type_traits>
#include <utility>


namespace md
{
    // neighbor_pair_forcefield implements md::forcefield. It computes short-
    // range interactions between every pair of particles that are close within
    // a given cutoff distance.
    //
    // This is a CRTP base class. Derived class must define two callbacks:
    //
    //     md::scalar neighbor_distance(md::system const& system)
    //     Returns the cutoff distance.
    //
    //     auto neighbor_pair_potential(
    //         md::system const& system,
    //         md::index i,
    //         md::index j
    //     )
    //     Returns the potential object for (i,j) pair.
    //
    template<typename Derived>
    class neighbor_pair_forcefield : public virtual md::forcefield
    {
    public:
        // compute_energy implements md::forcefield.
        md::scalar compute_energy(md::system const& system) override
        {
            md::array_view<md::point const> positions = system.view_positions();
            md::scalar sum = 0;

            for (auto const pair : get_neighbor_list(system)) {
                md::index const i = pair.first;
                md::index const j = pair.second;

                auto const pot = derived().neighbor_pair_potential(system, i, j);
                auto const r = positions[i] - positions[j];

                sum += pot.evaluate_energy(r);
            }

            return sum;
        }

        // compute_force implements md::forcefield.
        void compute_force(md::system const& system, md::array_view<md::vector> forces) override
        {
            md::array_view<md::point const> positions = system.view_positions();

            for (auto const pair : get_neighbor_list(system)) {
                md::index const i = pair.first;
                md::index const j = pair.second;

                auto const pot = derived().neighbor_pair_potential(system, i, j);
                auto const r = positions[i] - positions[j];

                auto const force = pot.evaluate_force(r);
                forces[i] += force;
                forces[j] -= force;
            }
        }

    private:
        // get_neighbor_list returns a reference to the up-to-date neighbor list
        // for the system.
        md::neighbor_list& get_neighbor_list(md::system const& system)
        {
            neighbor_list_.update(
                system.view_positions(),
                derived().neighbor_distance(system)
            );
            return neighbor_list_;
        }

        // derived returns a reference to this object as the CRTP derived class.
        Derived& derived()
        {
            return static_cast<Derived&>(*this);
        }

        md::neighbor_list neighbor_list_;
    };

    template<typename PotFun>
    class basic_neighbor_pair_forcefield
        : public md::neighbor_pair_forcefield<basic_neighbor_pair_forcefield<PotFun>>
    {
    public:
        explicit basic_neighbor_pair_forcefield(PotFun potfun)
            : potfun_{potfun}
        {
        }

        basic_neighbor_pair_forcefield& set_neighbor_distance(md::scalar ndist)
        {
            ndist_ = ndist;
            return *this;
        }

        md::scalar neighbor_distance(md::system const&) const
        {
            return ndist_;
        }

        auto neighbor_pair_potential(md::system const&, md::index i, md::index j) const
        {
            return potfun_(i, j);
        }

    private:
        PotFun potfun_;
        md::scalar ndist_;
    };

    // make_neighbor_pair_forcefield implements md::neighbor_pair_forcefield
    // with given potential object or lambda returning a potential object.
    template<typename P>
    auto make_neighbor_pair_forcefield(P pot)
    {
        auto potfun = detail::make_pair_potfun(pot);
        using potfun_type = decltype(potfun);
        return md::basic_neighbor_pair_forcefield<potfun_type>{potfun};
    }
}

//------------------------------------------------------------------------------
// md/forcefield/point_source_forcefield.hpp
//------------------------------------------------------------------------------

// This module provides a template forcefield implementation that computes field
// force from a point source.


namespace md
{
    // point_source_forcefield computes field interaction of particles and a
    // fixed point source.
    //
    // This is a CRTP base class. Derived class must implement a callback:
    //
    //     auto point_source_potential(
    //         md::system const& system,
    //         md::index i
    //     )
    //     Returns the potential object for a particle.
    //
    template<typename Derived>
    class point_source_forcefield : public virtual md::forcefield
    {
    public:
        // set_point_source sets a source point.
        Derived& set_point_source(md::point pt)
        {
            source_ = pt;
            return derived();
        }

        // compute_energy implements md::forcefield.
        md::scalar compute_energy(md::system const& system) override
        {
            md::array_view<md::point const> positions = system.view_positions();

            md::scalar sum = 0;

            for (md::index i = 0; i < system.particle_count(); i++) {
                md::vector const r = positions[i] - source_;

                sum += derived()
                    .point_source_potential(system, i)
                    .evaluate_energy(r);
            }

            return sum;
        }

        // compute_force implements md::forcefield.
        void compute_force(md::system const& system, md::array_view<md::vector> forces) override
        {
            md::array_view<md::point const> positions = system.view_positions();

            for (md::index i = 0; i < system.particle_count(); i++) {
                md::vector const r = positions[i] - source_;

                forces[i] += derived()
                    .point_source_potential(system, i)
                    .evaluate_force(r);
            }
        }

    private:
        // derived returns a reference to this as the CRTP derived class.
        Derived& derived()
        {
            return static_cast<Derived&>(*this);
        }

        md::point source_;
    };

    template<typename PotFun>
    class basic_point_source_forcefield
        : public md::point_source_forcefield<basic_point_source_forcefield<PotFun>>
    {
    public:
        explicit basic_point_source_forcefield(PotFun potfun)
            : potfun_{potfun}
        {
        }

        auto point_source_potential(md::system const&, md::index i) const
        {
            return potfun_(i);
        }

    private:
        PotFun potfun_;
    };

    // make_point_source_forcefield implements md::point_source_forcefield
    // with given potential object or lambda returning a potential object.
    template<typename P>
    auto make_point_source_forcefield(P pot)
    {
        auto potfun = detail::make_field_potfun(pot);
        using potfun_type = decltype(potfun);
        return md::basic_point_source_forcefield<potfun_type>{potfun};
    }
}

//------------------------------------------------------------------------------
// md/forcefield/sequential_pair_forcefield.hpp
//------------------------------------------------------------------------------

// This module provides a template forcefield implementation that computes
// interactions between sequentially numbered particles.

#include <utility>
#include <vector>


namespace md
{
    // sequential_pair_forcefield implements md::forcefield. It computes
    // interactions between every consecutive pair of particles in given
    // segments.
    //
    // This is a CRTP base class. Derived class must define a callback:
    //
    //     auto sequential_pair_potential(
    //         md::system const& system,
    //         md::index i,
    //         md::index j
    //     )
    //     Returns the potential object for (i,j) pair.
    //
    template<typename Derived>
    class sequential_pair_forcefield : public virtual md::forcefield
    {
    public:
        // add_segment marks all adjacent particles in a segment as interacting.
        // The range [first,last] is inclusive.
        Derived& add_segment(md::index first, md::index last)
        {
            segments_.emplace_back(first, last);
            return derived();
        }

        // compute_energy implements md::forcefield.
        md::scalar compute_energy(md::system const& system) override
        {
            md::array_view<md::point const> positions = system.view_positions();

            md::scalar sum = 0;

            for (std::pair<md::index, md::index> segment : segments_) {
                for (md::index i = segment.first; i < segment.second; i++) {
                    md::index const j = i + 1;
                    md::vector const r = positions[i] - positions[j];

                    auto const pot = derived().sequential_pair_potential(system, i, j);
                    md::scalar const energy = pot.evaluate_energy(r);

                    sum += energy;
                }
            }

            return sum;
        }

        // compute_force implements md::forcefield.
        void compute_force(md::system const& system, md::array_view<md::vector> forces) override
        {
            md::array_view<md::point const> positions = system.view_positions();

            for (std::pair<md::index, md::index> segment : segments_) {
                for (md::index i = segment.first; i < segment.second; i++) {
                    md::index const j = i + 1;
                    md::vector const r = positions[i] - positions[j];

                    auto const pot = derived().sequential_pair_potential(system, i, j);
                    md::vector const force = pot.evaluate_force(r);

                    forces[i] += force;
                    forces[j] -= force;
                }
            }
        }

    private:
        // derived returns a reference to this object as the CRTP derived class.
        Derived& derived()
        {
            return static_cast<Derived&>(*this);
        }

        std::vector<std::pair<md::index, md::index>> segments_;
    };

    template<typename PotFun>
    class basic_sequential_pair_forcefield
        : public md::sequential_pair_forcefield<basic_sequential_pair_forcefield<PotFun>>
    {
    public:
        explicit basic_sequential_pair_forcefield(PotFun potfun)
            : potfun_{potfun}
        {
        }

        auto sequential_pair_potential(md::system const&, md::index i, md::index j) const
        {
            return potfun_(i, j);
        }

    private:
        PotFun potfun_;
    };

    // make_sequential_pair_forcefield implements md::sequential_pair_forcefield
    // with given potential object or lambda returning a potential object.
    template<typename P>
    auto make_sequential_pair_forcefield(P pot)
    {
        auto potfun = detail::make_pair_potfun(pot);
        using potfun_type = decltype(potfun);
        return md::basic_sequential_pair_forcefield<potfun_type>{potfun};
    }
}

//------------------------------------------------------------------------------
// md/forcefield/detail/triple_potfun.hpp
//------------------------------------------------------------------------------

// This module implements a internal utility to normalize triple potential
// functor into a potential functor factory. Used by make_* family of functions.

#include <utility>


namespace md
{
    namespace detail
    {
        template<typename P>
        struct triple_potential_factory
        {
            P potential;

            inline P operator()(md::index, md::index, md::index) const
            {
                return potential;
            }
        };

        template<
            typename PotFun,
            typename = decltype(std::declval<PotFun>()(md::index{}, md::index{}, md::index{}))
        >
        PotFun make_triple_potfun(PotFun potfun)
        {
            return potfun;
        }

        template<typename P, typename... Dummy>
        triple_potential_factory<P> make_triple_potfun(P pot, Dummy...)
        {
            return triple_potential_factory<P>{pot};
        }
    }
}

//------------------------------------------------------------------------------
// md/forcefield/sequential_triple_forcefield.hpp
//------------------------------------------------------------------------------

// This module provides a template forcefield implementation that computes
// interactions among sequentially numbered particle triplets.

#include <tuple>
#include <utility>
#include <vector>


namespace md
{
    // sequential_triple_forcefield implements md::forcefield. It computes
    // interactions among every consecutive triple of particles in given
    // segments.
    //
    // This is a CRTP base class. Derived class must define a callback:
    //
    //     auto sequential_triple_potential(
    //         md::system const& system,
    //         md::index i,
    //         md::index j,
    //         md::index k
    //     )
    //     Returns the potential object for (i,j,k) pair.
    //
    template<typename Derived>
    class sequential_triple_forcefield : public virtual md::forcefield
    {
    public:
        // add_segment marks all consecutive particle triplets in a segment as
        // interacting. The range [first,last] is inclusive.
        Derived& add_segment(md::index first, md::index last)
        {
            segments_.emplace_back(first, last);
            return derived();
        }

        // compute_energy implements md::forcefield.
        md::scalar compute_energy(md::system const& system) override
        {
            md::array_view<md::point const> positions = system.view_positions();

            md::scalar sum = 0;

            for (std::pair<md::index, md::index> const segment : segments_) {
                for (md::index i = segment.first; i < segment.second - 1; i++) {
                    md::index const j = i + 1;
                    md::index const k = i + 2;
                    md::vector const rij = positions[i] - positions[j];
                    md::vector const rjk = positions[j] - positions[k];

                    md::scalar const energy = derived()
                        .sequential_triple_potential(system, i, j, k)
                        .evaluate_energy(rij, rjk);

                    sum += energy;
                }
            }

            return sum;
        }

        // compute_force implements md::forcefield.
        void compute_force(md::system const& system, md::array_view<md::vector> forces) override
        {
            md::array_view<md::point const> positions = system.view_positions();

            for (std::pair<md::index, md::index> const segment : segments_) {
                for (md::index i = segment.first; i < segment.second - 1; i++) {
                    md::index const j = i + 1;
                    md::index const k = i + 2;
                    md::vector const rij = positions[i] - positions[j];
                    md::vector const rjk = positions[j] - positions[k];

                    auto const force = derived()
                        .sequential_triple_potential(system, i, j, k)
                        .evaluate_force(rij, rjk);

                    forces[i] += std::get<0>(force);
                    forces[j] += std::get<1>(force);
                    forces[k] += std::get<2>(force);
                }
            }
        }

    private:
        // derived returns a reference to this object as the CRTP derived class.
        Derived& derived()
        {
            return static_cast<Derived&>(*this);
        }

        std::vector<std::pair<md::index, md::index>> segments_;
    };

    template<typename PotFun>
    class basic_sequential_triple_forcefield
        : public md::sequential_triple_forcefield<basic_sequential_triple_forcefield<PotFun>>
    {
    public:
        explicit basic_sequential_triple_forcefield(PotFun potfun)
            : potfun_{potfun}
        {
        }

        auto sequential_triple_potential(
            md::system const&, md::index i, md::index j, md::index k
        ) const
        {
            return potfun_(i, j, k);
        }

    private:
        PotFun potfun_;
    };

    // make_sequential_triple_forcefield implements
    // md::sequential_triple_forcefield with given potential object or lambda
    // returning a potential object.
    template<typename P>
    auto make_sequential_triple_forcefield(P pot)
    {
        auto potfun = detail::make_triple_potfun(pot);
        using potfun_type = decltype(potfun);
        return md::basic_sequential_triple_forcefield<potfun_type>{potfun};
    }
}

//------------------------------------------------------------------------------
// md/forcefield/sphere_surface_forcefield.hpp
//------------------------------------------------------------------------------

// This module provides a template forcefield implementation that computes
// field force acting on particles near a spherical surface.

#include <cmath>


namespace md
{
    // sphere is a sphere in the three-dimensional space.
    struct sphere
    {
        // Center. Defaults to the origin.
        md::point center;

        // Radius. Defaults to 1.
        md::scalar radius = 1;

        // implicit returns the implicit sphere function evaluated at pt:
        // f(x,y,z) = x^2 + y^2 + z^2 - R^2.
        md::scalar implicit(md::point pt) const
        {
            return (pt - center).squared_norm() - radius * radius;
        }
    };

    // sphere_surface_forcefield computes field interaction of particles and a
    // spherical surface.
    //
    // This is a CRTP base class. Callbacks are:
    //
    //     auto sphere_inward_potential(
    //         md::system const& system,
    //         md::index i
    //     )
    //     Returns the potential object for a particle inside sphere. It
    //     defaults to a zero potential if not defined.
    //
    //     auto sphere_outward_potential(
    //         md::system const& system,
    //         md::index i
    //     )
    //     Returns the potential object for a particle outside sphere. It
    //     defaults to a zero potential if not defined.
    //
    template<typename Derived>
    class sphere_surface_forcefield : public virtual md::forcefield
    {
    public:
        // set_ellipsoid changes the ellipsoid to given one. Default is the unit
        // sphere placed at the origin.
        Derived& set_sphere(md::sphere sphere)
        {
            sphere_ = sphere;
            return derived();
        }

        // compute_energy implements md::forcefield.
        md::scalar compute_energy(md::system const& system) override
        {
            md::point const center = sphere_.center;
            md::scalar const radius = sphere_.radius;
            md::scalar const radius2 = radius * radius;

            md::array_view<md::point const> positions = system.view_positions();

            md::scalar sum = 0;

            for (md::index i = 0; i < system.particle_count(); i++) {
                md::vector const r = positions[i] - center;
                md::scalar const r2 = r.squared_norm();
                md::scalar const r1 = std::sqrt(r2);

                if (r2 == 0) {
                    continue;
                }

                md::scalar const scale = radius / r1;
                md::vector const s = r - scale * r;

                if (r2 < radius2) {
                    auto const pot = derived().sphere_inward_potential(system, i);
                    sum += pot.evaluate_energy(s);
                } else {
                    auto const pot = derived().sphere_outward_potential(system, i);
                    sum += pot.evaluate_energy(s);
                }
            }
            return sum;
        }

        // compute_force implements md::forcefield.
        void compute_force(md::system const& system, md::array_view<md::vector> forces) override
        {
            md::point const center = sphere_.center;
            md::scalar const radius = sphere_.radius;
            md::scalar const radius2 = radius * radius;

            md::array_view<md::point const> positions = system.view_positions();

            for (md::index i = 0; i < system.particle_count(); i++) {
                md::vector const r = positions[i] - center;
                md::scalar const r2 = r.squared_norm();
                md::scalar const r1 = std::sqrt(r2);

                if (r2 == 0) {
                    continue;
                }

                md::scalar const scale = radius / r1;
                md::vector const s = r - scale * r;

                md::vector force;

                if (r2 < radius2) {
                    auto const pot = derived().sphere_inward_potential(system, i);
                    force = pot.evaluate_force(s);
                } else {
                    auto const pot = derived().sphere_outward_potential(system, i);
                    force = pot.evaluate_force(s);
                }

                md::vector const aniso = scale * (force.project(r) - force);

                forces[i] += force + aniso;
            }
        }

        // sphere_inward_potential by default returns a zero potential.
        md::constant_potential sphere_inward_potential(md::system const&, md::index) const
        {
            return md::constant_potential{0};
        }

        // sphere_outward_potential by default returns a zero potential.
        md::constant_potential sphere_outward_potential(md::system const&, md::index) const
        {
            return md::constant_potential{0};
        }

    private:
        // derived returns a reference to this as the CRTP derived class.
        Derived& derived()
        {
            return static_cast<Derived&>(*this);
        }

        md::sphere sphere_;
    };

    template<typename PotFun>
    class basic_sphere_inward_forcefield
        : public md::sphere_surface_forcefield<basic_sphere_inward_forcefield<PotFun>>
    {
    public:
        explicit basic_sphere_inward_forcefield(PotFun potfun)
            : potfun_{potfun}
        {
        }

        auto sphere_inward_potential(md::system const&, md::index i) const
        {
            return potfun_(i);
        }

    private:
        PotFun potfun_;
    };

    template<typename PotFun>
    class basic_sphere_outward_forcefield
        : public md::sphere_surface_forcefield<basic_sphere_outward_forcefield<PotFun>>
    {
    public:
        explicit basic_sphere_outward_forcefield(PotFun potfun)
            : potfun_{potfun}
        {
        }

        auto sphere_outward_potential(md::system const&, md::index i) const
        {
            return potfun_(i);
        }

    private:
        PotFun potfun_;
    };

    // make_sphere_inward_forcefield implements md::sphere_surface_forcefield
    // with given potential object or lambda returning a potential object.
    template<typename P>
    auto make_sphere_inward_forcefield(P pot)
    {
        auto potfun = detail::make_field_potfun(pot);
        using potfun_type = decltype(potfun);
        return md::basic_sphere_inward_forcefield<potfun_type>{potfun};
    }

    // make_sphere_outward_forcefield implements md::sphere_surface_forcefield
    // with given potential object or lambda returning a potential object.
    template<typename P>
    auto make_sphere_outward_forcefield(P pot)
    {
        auto potfun = detail::make_field_potfun(pot);
        using potfun_type = decltype(potfun);
        return md::basic_sphere_outward_forcefield<potfun_type>{potfun};
    }
}

//------------------------------------------------------------------------------
// md/simulation/detail/brownian_timestepper.hpp
//------------------------------------------------------------------------------

// This module provides timestepping algorithms used to implement for Brownian
// dynamics simulation.

#include <algorithm>
#include <cmath>


namespace md
{
    namespace detail
    {
        // brownian_timestepper abstracts the algorithm for determining the
        // timestep of Brownian dynamics simulation.
        class brownian_timestepper
        {
        public:
            virtual ~brownian_timestepper() = default;

            // determine_timestep computes the timestep for given context.
            virtual md::scalar determine_timestep(
                md::array_view<md::scalar const> mobilities,
                md::array_view<md::vector const> forces,
                md::scalar temperature
            ) const = 0;
        };


        // monotonic_brownian_timestepper is a brownian_timestepper with a fixed
        // timestep.
        class monotonic_brownian_timestepper : public detail::brownian_timestepper
        {
        public:
            // Constructor takes the fixed timestep value.
            explicit monotonic_brownian_timestepper(md::scalar timestep)
                : timestep_{timestep}
            {
            }

            // determine_timestep returns the preconfigured timestep value.
            md::scalar determine_timestep(
                md::array_view<md::scalar const>,
                md::array_view<md::vector const>,
                md::scalar
            ) const override
            {
                return timestep_;
            }

        private:
            md::scalar timestep_;
        };


        // solve_brownian_timestep estimates the amount of time for a Brownian
        // particle to travel given distance. This function is used to implement
        // adaptive_brownian_timestepper below.
        //
        // distance    : Distance the particle would travel
        // mobility    : Mobility of the particle
        // force2      : Squared force acting on the particle
        // temperature : Temperature in the unit of energy
        //
        inline md::scalar solve_brownian_timestep(
            md::scalar distance,
            md::scalar mobility,
            md::scalar force2,
            md::scalar temperature
        )
        {
            constexpr md::scalar epsilon = 1e-6;
            constexpr md::scalar random_walk_factor = 2.55;

            md::scalar const a = mobility * mobility * force2;
            md::scalar const b = random_walk_factor * mobility * temperature;
            md::scalar const c = distance * distance;

            if (a * c < epsilon * b * b) {
                return c / b;
            }

            return (-b + std::sqrt(b * b + 4 * a * c)) / (2 * a);
        }


        // adaptive_brownian_timestepper changes timestep to limit the expected
        // particle dispalcement to specified maximum.
        class adaptive_brownian_timestepper : public detail::brownian_timestepper
        {
        public:
            // Constructor takes the upper bound of timestep and displacement.
            explicit adaptive_brownian_timestepper(md::scalar max_timestep, md::scalar distance)
                : max_timestep_{max_timestep}
                , distance_{distance}
            {
            }

            // determine_timestep returns timestep value that is small enough to
            // limit the expected displacement of particles within the upper
            // bound.
            md::scalar determine_timestep(
                md::array_view<md::scalar const> mobilities,
                md::array_view<md::vector const> forces,
                md::scalar temperature
            ) const override
            {
                md::scalar timestep = max_timestep_;

                for (md::index i = 0; i < mobilities.size(); i++) {
                    md::scalar dt = max_timestep_;

                    md::scalar const mobility = mobilities[i];
                    md::scalar const force2 = forces[i].squared_norm();

                    if (mobility != 0 || force2 != 0) {
                        dt = detail::solve_brownian_timestep(
                            distance_,
                            mobility,
                            force2,
                            temperature
                        );
                    }

                    timestep = std::min(timestep, dt);
                }

                return timestep;
            }

        private:
            md::scalar max_timestep_;
            md::scalar distance_;
        };
    }
}

//------------------------------------------------------------------------------
// md/simulation/detail/brownian_simulator.hpp
//------------------------------------------------------------------------------

// This module provides a helper class to simulate Brownian dynamics.

#include <cmath>
#include <cstdint>
#include <utility>
#include <vector>


namespace md
{
    namespace detail
    {
        class brownian_simulator
        {
        public:
            brownian_simulator(
                md::system& system,
                detail::brownian_timestepper& timestepper,
                md::scalar temperature,
                std::uint64_t seed
            )
                : system_{system}
                , timestepper_{timestepper}
                , temperature_{temperature}
            {
                random_.seed(seed);

                forces_.resize(system.particle_count());
                weiners_.resize(system.particle_count());
            }

            // simulate_step simulates a discretized step.
            void simulate_step()
            {
                md::array_view<md::scalar const> mobilities = system_.view_mobilities();
                md::array_view<md::point> positions = system_.view_positions();
                md::array_view<md::vector> forces = forces_;
                md::array_view<md::vector> weiners = weiners_;

                // Second-order BAOAB limit scheme.

                system_.compute_force(forces);

                md::scalar const timestep = timestepper_.determine_timestep(
                    mobilities,
                    forces,
                    temperature_
                );

                md::normal_distribution<md::scalar> normal;

                for (md::index i = 0; i < system_.particle_count(); i++) {
                    md::scalar const mu_dt = timestep * mobilities[i];
                    md::scalar const sigma = std::sqrt(2 * temperature_ * mu_dt);
                    md::vector const weiner = {
                        sigma * normal(random_),
                        sigma * normal(random_),
                        sigma * normal(random_)
                    };

                    positions[i] += mu_dt * forces[i];
                    positions[i] += 0.5 * (weiner + weiners[i]);
                    weiners[i] = weiner;
                }
            }

        private:
            md::system& system_;
            detail::brownian_timestepper& timestepper_;
            md::scalar temperature_;
            std::vector<md::vector> forces_;
            std::vector<md::vector> weiners_;
            md::random_engine random_;
        };
    }
}

//------------------------------------------------------------------------------
// md/simulation/brownian_dynamics.hpp
//------------------------------------------------------------------------------

// This module provides a function for simulating Brownian dynamics.

#include <cstdint>
#include <functional>
#include <memory>


namespace md
{
    // brownian_dynamics_config holds Brownian dynamics parameters.
    struct brownian_dynamics_config
    {
        // Temperature of the environment in the unit of (thermal) energy. It
        // can be zero.
        md::scalar temperature = 1;

        // Time discretization step.
        md::scalar timestep = 1;

        // Set this to nonzero to adaptively determine timestep so that the mean
        // displacement is bounded by spacestep.
        md::scalar spacestep = 0;

        // Number of steps to simulate.
        md::step steps = 1;

        // Seed for pseudo-random number generator.
        std::uint64_t seed = 0;

        // Optional callback function called after each step.
        std::function<void(md::step)> callback = {};
    };

    // simulate_brownian_dynamics simulates Brownian dynamics of the system. It
    // uses mobility and position particle attributes.
    inline void simulate_brownian_dynamics(md::system& system, md::brownian_dynamics_config config)
    {
        std::unique_ptr<detail::brownian_timestepper> timestepper;

        if (config.spacestep != 0) {
            timestepper = std::make_unique<detail::adaptive_brownian_timestepper>(
                config.timestep,
                config.spacestep
            );
        } else {
            timestepper = std::make_unique<detail::monotonic_brownian_timestepper>(
                config.timestep
            );
        }

        detail::brownian_simulator simulator(system, *timestepper, config.temperature, config.seed);

        for (md::step step_ctr = 1; step_ctr <= config.steps; step_ctr++) {
            simulator.simulate_step();

            if (config.callback) {
                config.callback(step_ctr);
            }
        }
    }
}

//------------------------------------------------------------------------------
// md/simulation/newtonian_dynamics.hpp
//------------------------------------------------------------------------------

// This module provides a function for simulating Newtonian dynamics.

#include <cmath>
#include <functional>
#include <vector>


namespace md
{
    // Parameters for Newtonian dynamics simulation.
    struct newtonian_dynamics_config
    {
        // Time discretization step.
        md::scalar timestep = 1;

        // Number of steps to simulate.
        md::step steps = 1;

        // Optional function called after each step.
        std::function<void(md::step)> callback;
    };

    // simulate_newtonian_dynamics simulates Newtonian dynamics of the system.
    // It uses mass, position and velocity particle attributes.
    inline void simulate_newtonian_dynamics(md::system& system, md::newtonian_dynamics_config config)
    {
        std::vector<md::vector> forces(system.particle_count());

        md::array_view<md::scalar const> masses = system.view_masses();
        md::array_view<md::point> positions = system.view_positions();
        md::array_view<md::vector> velocities = system.view_velocities();

        // Velocity Verlet scheme.

        for (md::step step_ctr = 1; step_ctr <= config.steps; step_ctr++) {
            md::scalar const timestep = config.timestep;

            for (md::index i = 0; i < system.particle_count(); i++) {
                velocities[i] += timestep / (2 * masses[i]) * forces[i];
                positions[i] += timestep * velocities[i];
            }

            system.compute_force(forces);

            for (md::index i = 0; i < system.particle_count(); i++) {
                velocities[i] += timestep / (2 * masses[i]) * forces[i];
            }

            if (config.callback) {
                config.callback(step_ctr);
            }
        }
    }
}


#endif
